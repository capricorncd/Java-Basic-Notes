{"./":{"url":"./","title":"Java","keywords":"","body":"Java Java平台应用 核心概念：JVM/JDK/JRE 搭建Java开发环境 使用工具开发Java程序 1995由Sun公司推出，2009被Oracle收购。 Java平台应用 核心概念：JVM/JDK/JRE JVM: Java Virtual Machine JDK: Java Development Kit (Java开发工具包) JRE: Java Runtime Environment (Java运行时环境) Java 开发环境搭建 安装JDK https://www.oracle.com/technetwork/java/javase/downloads/index.html JDK8 https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 库文件，以.jar结尾 window 10 配置环境变量（系统变量） # 配置JDK安装路径 JAVA_HOME C:\\Program Files\\Java\\jdk1.8.0_172 # 配置类库文件的位置 CLASSPATH .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar # 配置JDK命令文件的位置 path C:\\ProgramFiles\\Java\\jdk1.8.0_172\\bin C:\\Program Files\\Java\\jdk1.8.0_172\\bin\\jre\\bin Mac 直接装jdk-8u201-macosx-x64.dmg就可以了。 使用工具开发Java程序 HelloWorld.java public class HelloWorld { public static void main(String[] args) { System.out.println(\"Welcome to Java world.\"); } } 使用bash，找到文件路径，执行 javac HelloWorld.java 此时，会在当前位置生产一个HelloWorld.class的字节码文件。 # 执行字节码文件，注意不能跟后缀名.class java HelloWorld # Welcome to Java world. 使用IDE开发 集成开发环境（IDE）是一类软件 将程序开发环境和程序调试环境集合在一起，提高开发效率。 Eclipse 开源免费的。下载地址 https://www.eclipse.org/downloads/ 开发流程: 1 创建Java项目 file -> New -> Java Project # Project name: hello 2 创建程序包 # src 目录 New -> Package # com.hello 3 编写Java源程序 com.hello -> New -> Class > Name: HelloTest IDE自动生成：HelloTest.java package com.hello; public class HelloTest { } 注意：类名class HelloTest一定要与文件名HelloTest.java相同。 4 运行Java程序 代码编辑拦，空白处鼠标右键 -> Run As -> Java Application ... 或者点击编辑器左上角的\"播放\"图标，run ... MyEclipse MyEclipse是对Eclipse的扩展，是一个十分优秀的用于开发Java、JavaEE的Eclipse插件集合。 https://www.myeclipsecn.com 程序的移植 从公司拷回屋里继续写... 拷贝项目代码 -> 到家，开电脑，打开软件 -> File -> Import -> General/Existing Project into Workspace -> Next -> Select root directory: [Broser] -> 找到文件 -> Finish 来自巨人的经验 多练、多问、自己动手，调试错误、复习和总结。 学虽容易，学好不易，且学且珍惜。 原教程出处 https://www.imooc.com/learn/85 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-01 20:38:19 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/first-season/variable-and-constant.html":{"url":"pages/first-season/variable-and-constant.html","title":"变量与常量","keywords":"","body":"变量与常量 Java关键字 Java 关键字是区分大小写 Java标识符 标识符就是用于给 Java 程序中变量、类、方法等命名的符号。 使用标识符时，需要遵守几条规则： 标识符可以由字母、数字、下划线（_）、美元符（$）组成，但不能包含 @、%、空格等其它特殊字符，不能以数字开头。譬如：123name 就是不合法。 标识符不能是 Java 关键字和保留字（ Java 预留的关键字，以后的升级版本中有可能作为关键字），但可以包含关键字和保留字。如：不可以使用 void 作为标识符，但是 Void 可以。 标识符是严格区分大小写的。 标识符的命名最好能反映出其作用，做到见名知意。 变量 在 Java 中，我们通过三个元素描述变量：变量类型、变量名以及变量值。 int a = 30; String b = \"this is String\"; 通常： 变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 createUserInfo。 变量命名时，尽量简短且能清楚的表达变量的作用，做到见名知意。如：定义变量名 studentName 保存“学生姓名”信息。 Java 变量名的长度没有限制，但 Java 语言是区分大小写的，所以price和Price 是两个完全不同的变量！ public class HelloWorld { public static void main(String[] args) { int hobby = 9999; System.out.println(hobby); } } Java中的数据类型 Java 语言是一种强类型语言。通俗点说就是，在 Java 中存储的数据都是有类型的，而且必须在编译时就确定其类型。 Java 中有两类数据类型： 在 Java 的领域里，基本数据类型变量存的是数据本身，而引用类型变量存的是保存数据的空间地址。 数据类型 说明 字节 应用 示例 int 整型 4 整数，如年龄/个数等 int age=21; double 双精度浮点型 8 小数，如商品价格/成绩平均分等 double price=21.5; float 单精度浮点型 4 小数，如身高等 float height=180.3f; char 字符型 2 单个字符，如性别男/女 char gander='男'; boolean 布尔型 1 表示真true或假false boolean flag=true; float变量赋值时，在数值后面添加字母f。 char变量赋值时，使用单引号'。 Java中变量的使用规则 Java 中的变量需要先声明后使用 变量使用时，可以声明变量的同时进行初始化 变量中每次只能赋一个值，但可以修改多次 main 方法中定义的变量必须先赋值，然后才能输出 String a; System.out.println(a); // error 虽然语法中没有提示错误，但在实际开发中，变量名不建议使用中文，容易产生安全隐患。譬如后期跨平台操作时出现乱码等等。 Java中的自动类型转换 自动类型转换: int a = 89; double b = a; System.out.println(b); // 89.0 自动类型转换是需要满足特定的条件: 目标类型能与源类型兼容，如 double 型兼容 int 型，但是 char 型不能兼容 int 型。 目标类型大于源类型，如 double 类型长度为 8 字节， int 类型为 4 字节，因此 double 类型的变量里直接可以存放 int 类型的数据，但反过来就不可以。 Java中的强制类型转换 double average = 74.9; int average2 = (int)average; System.out.println(average); // 74.9 System.out.println(average2); // 74 强制类型转换可能会造成数据的丢失 Java常量的应用 语法 final 常量名 = 值; 程序中使用常量可以提高代码的可维护性。 常量名一般使用大写字符。 Java中使用注释 在编写程序时，经常需要添加一些注释，用以描述某段代码的作用。 一般来说，对于一份规范的程序源代码而言，注释应该占到源代码的 1/3 以上。因此，注释是程序源代码的重要组成部分。 Java 中注释有三种类型：单行注释、多行注释、文档注释。 package com.test /** * 这是文档注释 * @author authorName * @version v1.0.0 */ public class TestDemo { /* * 这是多行注释 * 可以包含多行内容 */ public static void main(String[] args) { // 这是单行注释 System.out.println(\"Hello World\"); } } 我们可以通过 javadoc 命令从文档注释中提取内容，生成程序的 API 帮助文档。 javadoc -d doc TestDemo.java 使用文档注释时还可以使用 javadoc 标记，生成更详细的文档信息： @author 标明开发该类模块的作者 @version 标明该类模块的版本 @see 参考转向，也就是相关主题 @param 对方法中某参数的说明 @return 对方法返回值的说明 @exception 对方法可能抛出的异常进行说明 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-01 20:38:19 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/first-season/operator.html":{"url":"pages/first-season/operator.html","title":"运算符","keywords":"","body":"运算符 算术运算符 赋值运算符 比较运算符 逻辑运算符 条件运算符 算术运算符 算术运算符主要用于进行基本的算术运算，如加法、减法、乘法、除法等。 赋值运算符 赋值运算符是指为变量或常量指定数值的符号。如可以使用 “=” 将右边的表达式结果赋给左边的操作数。 比较运算符 比较运算符用于判断两个数据的大小，例如：大于、等于、不等于。比较的结果是一个布尔值（ true 或 false ）。 >、、>=、 只支持左右两边操作数是数值类型 ==、!= 两边的操作数既可以是数值类型，也可以是引用类型 逻辑运算符 逻辑运算符主要用于进行逻辑运算。Java 中常用的逻辑运算符如下表所示： 我们可以从“投票选举”的角度理解逻辑运算符： 1、 与：要求所有人都投票同意，才能通过某议题 2、 或：只要求一个人投票同意就可以通过某议题 3、 非：某人原本投票同意，通过非运算符，可以使其投票无效 4、 异或：有且只能有一个人投票同意，才可以通过某议题 当使用逻辑运算符时，我们会遇到一种很有趣的“短路”现象。 譬如：( one > two ) && ( one two 运行结果为 false , 则系统就认为已经没有必要执行右侧的 one 同理，在( one > two ) || ( one 条件运算符 条件运算符（ ? : ）也称为 “三元运算符”。 语法形式： 布尔表达式 ？表达式1 ：表达式2 运算符的优先级 所谓优先级，就是在表达式中的运算顺序。 优先级 运算符 1 () 2 ! +正 -负 ++ -- 3 * / % 4 +加 -减 5 >= 6 == != 7 ^ 8 && 9 或 10 ? :三元运算符 11 = += -= *= /= %= 级别为 1 的优先级最高，级别 11 的优先级最低。 ( 11+ 3* 8 ) / 4 % 3; // 2 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-01 23:00:57 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/first-season/flow-control-statement.html":{"url":"pages/first-season/flow-control-statement.html","title":"流程控制语句","keywords":"","body":"流程控制语句 if, if else if (BooleanConditionalExpression) { // do something } else { // do something } if (BooleanConditionalExpression1) { // do something } else if (BooleanConditionalExpression2) { // do something } else { // do something } switch switch (Expression) { case Value1: // do something break; case Value1: // do something break; default: // do something } while int i = 1; while (i for for (循环变量初始化; 循环条件; 循环变量变化) { // 循环操作 } 执行过程： 执行循环变量初始化部分，设置循环的初始状态，此部分在整个循环中只执行一次 进行循环条件的判断，如果条件为 true ，则执行循环体内代码；如果为 false ，则直接退出循环 执行循环变量变化部分，改变循环变量的值，以便进行下一次条件判断 依次重新执行、、，直到退出循环 特点：相比 while 和 do...while 语句结构更加简洁易读 注意： for 关键字后面括号中的三个表达式必须用 “;” 隔开，三个表达式都可以省略，但 “;” 不能省略。 a. 省略“循环变量初始化”，可以在 for 语句之前由赋值语句进行变量初始化操作，如: int i = 0; for (; i b. 省略“循环条件”，可能会造成循环将一直执行下去，也就是我们常说的“死循环”现象，如: for (int i = 0; ; i++) { // do something } 在编程过程中要避免“死循环”的出现，因此，对于上面的代码可以在循环体中使用 break 强制跳出循环。 c. 省略“循环变量变化”，可以在循环体中进行循环变量的变化，如： for (int i = 0; i for 循环变量初始化和循环变量变化部分，可以是使用 “,” 同时初始化或改变多个循环变量的值，如： for (int i = 1, j = 5; i 代码中，初始化变量部分同时对两个变量 i 和 j 赋初值，循环变量变化部分也同时对两个变量进行变化。 循环条件部分可以使用逻辑运算符组合的表达式，表示复杂判断条件，但一定注意运算的优先级，如： for (int i = 1; i 代码中，必须同时满足变量 i 小于 10 ，并且 i 不等于 5 时才会进行循环，输出变量 i 的值。 break for (int i = 0; i continue for (int i = 0; i 编程题 /* * 为指定成绩加分，直到分数大于等于 60 为止， * 输出加分前和加分后的成绩，并统计加分的次数 */ Test1.java package com.test1; import java.util.Scanner; /* * 为指定成绩加分，直到分数大于等于 60 为止， * 输出加分前和加分后的成绩，并统计加分的次数 */ /* * 使用Scanner工具类来获取用户输入的成绩信息 * Scanner类位于java.util包中，使用时需要导入 * 步骤： * 1.导入java.util.Scanner * 2.创建Scanner对象 * 3.接收并保存用户输入的值 */ public class Test1 { public static void main(String[] args) { // create Scanner Object Scanner input = new Scanner(System.in); // notice // println输出后会换行，print不会 System.out.print(\"请输入考试成绩（整数）：\"); // score // get user input score, and save to variable int score = input.nextInt(); // count int count = 0; System.out.println(\"origin score: \" + score); while (score /* * 求3个班级，各4名学生的平均成绩 */ Test2.java package com.test2; import java.util.Scanner; /* * 求3个班级，各4名学生的平均成绩 */ public class Test2 { public static void main(String[] args) { Scanner input = new Scanner(System.in); int classNum = 3; int studentNum = 4; int score; double sum; double avgs; for (int i = 1; i © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-01 20:38:19 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/first-season/array.html":{"url":"pages/first-season/array.html","title":"数组","keywords":"","body":"数组 int[] scores = { 1, 2, 3, 4, 5, 6, 7 } System.out.println(scores[2]); // 3 声明和初始化赋值 声明数组 语法： 数据类型[ ] 数组名； 或者 数据类型 数组名[ ]； 其中，数组名可以是任意合法的变量名，如： // 存储学生成绩的数组，类型为整型 int[] scores; // 存在身高的数组，类型为浮点型 double height[]; // 存储学生姓名的数组，类型为字符串 String[] names; 分配空间 简单地说，就是指定数组中最多可存储多少个元素 语法： 数组名 = new 数据类型 [ 数组长度 ]; 其中，数组长度就是数组中能存放元素的个数，如： scores = new int[5]; height = new double[5]; names = new String[5]; 也可以将上面的两个步骤合并，在声明数组的同时为它分配空间 int[] scores = new int[5]; 赋值 scores[0] = 100; scores[1] = 99; 处理数组中数据 System.out.println(scores[1]); // 99 同时声明数组、分配空间和赋值： int[] scores = {89, 90, 100, 78}; public class HelloWorld { public static void main(String[] args) { // 定义一个长度为5的字符串数组，保存考试科目信息 String[] subjects = new String[5]; // 分别为数组中的元素赋值 subjects[0] = \"Oracle\"; subjects[1] = \"PHP\"; subjects[2] = \"Linux\"; subjects[3] = \"Java\"; subjects[4] = \"HTML\"; System.out.println(\"数组中第4个科目为：\" + subjects[3]); } } 例子： // error: // Cannot define dimension expressions when an array initializer is provided int[ ] score = new int[ 4 ] { 90, 12, 34, 77 }; // error: // Variable must provide either dimension expressions // or an array initializer int[ ] score = new int[ ]; // right int score[ ] = new int[ ] { 34, 90, 87, 54, 24 }; 循环操作 int[] arr = { 34, 53, 98, 23}; for (int i = 0; i 数组名.length 用于获取数组的长度。 数组下标的范围是 0 至 数组长度-1 ，如果越界访问，就会报错。 // Array.java Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 4 at com.array.Array.main(Array.java:15) 练习： 输出数组中的最大值、最小值和平均值 public class Array { public static void main(String[] args) { // 定义一个整型数组，并赋初值 int[] nums = new int[] { 61, 23, 4, 74, 13, 148, 20 }; int max = nums[0]; // 假定最大值为数组中的第一个元素 int min = nums[0]; // 假定最小值为数组中的第一个元素 double sum = 0;// 累加值 double avg = 0;// 平均值 for (int i = 0; i 0 && nums[i] > max) { max = nums[i]; } // 如果当前值小于min，则替换min的值 if (i > 0 && nums[i] 使用 Arrays 类操作 Java 中的数组 Arrays 类是 Java 中提供的一个工具类，在 java.util 包中。该类中包含了一些方法用来直接操作数组，比如可直接实现数组的排序、搜索等 排序 语法： Arrays.sort(数组名); public class Array { public static void main(String[] args) { // 定义一个整型数组，并赋初值 int[] nums = new int[] { 61, 23, 4, 74, 13, 148, 20 }; Arrays.sort(nums); System.out.println(\"排序后的首尾数为：\" + nums[0] + \", \" + nums[nums.length - 1]); System.out.println(\"toString: \" + Arrays.toString(nums)); } } 将数组转换为字符串 语法： Arrays.toString(数组名); foreach foreach 并不是 Java 中的关键字，是 for 语句的特殊简化版本，在遍历数组、集合时， foreach 更简单便捷。 // 语法 for (元素类型 元素变量 : 遍历对象) { // do something } for (int i : nums) { System.out.println(\"print by foreach: \" + i); } 二维数组 声明数组/分配空间 数据类型[][] 数组名 = new 数据类型[行数][列数]; 或 数据类型[][] 数组名; 数组名 = new 数据类型[行数][列数]; CODE Array.java package com.array; import java.util.Arrays; /* public class Array { public static void main(String[] args) { // right: int score[] = new int[]{45, 56, 76, 23}; // error: // Cannot define dimension expressions // when an array initializer is provided // int score[] = new int[4]{45, 56, 76, 23}; // error: // Variable must provide either dimension expressions // or an array initializer // int[ ] score = new int[ ]; System.out.println(score[4]); } } */ /* public class Array { public static void main(String[] args) { // 定义一个整型数组，并赋初值 int[] nums = new int[] { 61, 23, 4, 74, 13, 148, 20 }; int max = nums[0]; // 假定最大值为数组中的第一个元素 int min = nums[0]; // 假定最小值为数组中的第一个元素 double sum = 0;// 累加值 double avg = 0;// 平均值 for (int i = 0; i 0 && nums[i] > max) { max = nums[i]; } // 如果当前值小于min，则替换min的值 if (i > 0 && nums[i] Test.java package com.array; import java.util.Arrays; /* * 创建指定长度的 int 型数组， * 并生成 100 以内随机数为数组中的每个元素赋值， * 然后输出数组 */ //public class Test { // public static void main(String[] args) { // Test ts = new Test(); // // create array // int[] arr = ts.createArray(8); // // System.out.println(Arrays.toString(arr)); // } // // public int[] createArray(int length) { // int[] arr = new int[length]; // for (int i = 0; i = 3) break; if (scores[i] >= 0 && scores[i] arr[i]) { temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } return arr; } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-01 20:38:19 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/first-season/function.html":{"url":"pages/first-season/function.html","title":"方法","keywords":"","body":"方法 语法 访问修饰符 返回值类型 方法名(参数列表) { 方法体 } 访问修饰符：方法允许被访问的权限范围，可以是 public、protected、private 甚至可以省略。其中 public 表示该方法可以被其他任何代码调用。 返回值类型：方法返回值的类型，如果方法不返回任何值，则为 void；如果有返回值，则需要指定返回值的类型，并且在方法体中使用 return 语句返回值。 方法名：定义的方法的名字，必须使用合法的标识符。 参数列表：传递给方法的参数列表，参数可以有多个，多个参数间以逗号隔开，每个参数由参数类型和参数名组成，以空格隔开。 根据方法是否带参、是否带返回值，可将方法分为四类: Ø 无参无返回值方法 Ø 无参带返回值方法 Ø 带参无返回值方法 Ø 带参带返回值方法 public void print(String str) { System.out.println(str); } example // Func.java public class Func { // 定义print方法 public void print(String str) { System.out.println(str); } public static void main(String[] args) { // 创建Func对象 Func fn = new Func(); // 调用print方法 fn.print(\"Hello world\"); } } 无参带返回值方法: public int sum() { int a = 1; int b = 3; return a + b; } 如果方法的返回类型为 void ，则方法中不能使用 return 返回值！ 方法的返回值最多只能有一个，不能返回多个值。 方法返回值的类型必须兼容，例如，如果返回值类型为 int ，则不能返回 String 型值。 带参无返回值方法: public int sum(int a, int b) { System.out.println(a + b); } 调用带参方法时，必须保证实参的数量、类型、顺序与形参一一对应 调用方法时，实参不需要指定数据类型 方法的参数可以是基本数据类型，如 int、double 等，也可以是引用数据类型，如 String、数组等 当方法参数有多个时，多个参数间以逗号分隔。 带参有返回值方法: public int sum(int a, int b) { return a + b; } Java 中方法的重载 什么是方法的重载呢？ 如果同一个类中包含了两个或两个以上方法名相同、方法参数的个数、顺序或类型不同的方法，则称为方法的重载，也可称该方法被重载了。如下所示 4 个方法名称都为 show ，但方法的参数有所不同，因此都属于方法的重载： // 无参数方法 public void show() { System.out.println(\"not arguments\"); } // 重载show方法，一个字符串参数 public void show(String name) { System.out.println(\"argument name: \" + name); } // 重载show方法，两个参数 public void show(String name, int age) { System.out.println(name + \" is \" + age + \" years old\"); } // 重载show方法，两个参数顺序不同 public void show(int age, String name) { System.out.println(\"The \" + age + \"-year-old people is \" + name + \".\"); } 如何区分调用的是哪个重载方法呢？ 当调用被重载的方法时， Java 会根据参数的个数和类型来判断应该调用哪个重载方法，参数完全匹配的方法将被执行。如： public static void main(String[] args) { Func fn = new Func(); fn.show(); // 调用无参数的show方法 fn.show(\"Juny\"); // 调用带有一个参数的show方法 fn.show(\"Juny\", 15); // 调用带有字符串+整型参数的show方法 } 判断方法重载的依据： 1、 必须是在同一个类中 2、 方法名相同 3、 方法参数的个数、顺序或类型不同 4、 与方法的修饰符或返回值没有关系 Test.java package com.test; import java.util.Arrays; /* * 创建指定长度的 int 型数组， * 并生成 100 以内随机数为数组中的每个元素赋值， * 然后输出数组 */ public class Test { public static void main(String[] args) { Test ts = new Test(); // create array int[] arr = ts.createArray(8); System.out.println(Arrays.toString(arr)); } public int[] createArray(int length) { int[] arr = new int[length]; for (int i = 0; i CODE Func.java package com.array; public class Func { public void print(String str) { System.out.println(str); } public int sum() { int a = 1; int b = 3; return a + b; } public static void main(String[] args) { Func f = new Func(); f.print(\"Hello world\" + f.sum()); } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-01 20:38:19 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/second-season/class-and-object.html":{"url":"pages/second-season/class-and-object.html","title":"类与对象","keywords":"","body":"类和对象 面向对象 对象的概念 什么是面向对象 类 什么是对象的属性 什么是对象的方法 类与对象的关系/区别 对象的概念 万物皆对象，客观存在的事物皆为对象。 什么是面向对象 人 -》关注 =》 事物信息 类 类是模子，确定对象将会拥有的特征（属性）和行为（方法）。 类的特点：类是对象的类型，具有相同属性和方法的一组对象的集合。 什么是对象的属性 属性：对象具有的各种特征，每个对象的每个属性都拥有特定值。 什么是对象的方法 方法：对象执行的操作。 类与对象的关系/区别 类是抽象的概念，仅仅是模板，不如说\"手机\"； 对象是一个你能够看得到，摸得着的具体实体。 \"手机\"类 对象 特征（属性）屏幕/CPU/内存 华为, 小米... 行为（方法）打电话/发短信 华为, 小米... 类的定义 类的重要性：所以Java程序都以类class为组织单元。 类的组成：属性和方法。 定义一个类的步骤： 定义类名，编写类的属性，编写类的方法 语法 public class 类名 { // 定义属性部分（成员变量） 类型 属性1; 类型 属性2; ... 类型 属性n; // 定义方法部分 方法1; 方法2; ... 方法n; } 例子 // Telphone.java package com.phone; // 1. 定义一个类Telphone public class Telphone { // 2. 属性（成员变量） float screenSize; float cpu; float memory; // 3. 方法 干什么 vodi call() { System.out.println(\"Telphone有打电话的功能\"); } vodi sendMessage() { System.out.println(\"Telphone有发短信的功能\"); } } 使用对象 使用对象的步骤： 1 创建对象 类名 对象名 = new 类名(); Telphone phone = new Telphone(); 2 使用对象 引用对象的属性：对象名.属性 // 给screenSize属性赋值5 phone.screenSize = 5; 引用对象的方法：对象名.方法名() // 调用sendMessage()方法 phone.sendMessage(); 完整例子： com.test/Telphone.java package com.test; public class Telphone { float screenSize; float cpu; float memory; void call() { System.out.println(\"call\"); } void sendMessage() { System.out.println(\"screenSize: \" + screenSize + \", cup: \" + cpu + \", memory: \" + memory); } } com.test/useTelphone.java package com.test; public class useTelphone { public static void main(String[] args) { // TODO Auto-generated method stub Telphone phone = new Telphone(); phone.sendMessage(); // 赋值 phone.screenSize = 5.4f; phone.cpu = 1.4f; phone.memory = 4.0f; phone.sendMessage(); } } 成员变量和局部变量 1 成员变量：在类中定义，用了描述对象将要有什么。 2 局部变量：在类的方法中定义，在方法中临时保存数据。 区别 成员变量 局部变量 作用域 在整个类内部都是可见的 仅限于定义它的方法中 初始值 Java会给成员变量一个初始值，调用时可以不赋值 不会赋初始值，调用前必须赋值 同一个方法中，不允许有同名局部变量。 两类变量同名时，局部变量具有更高的优先级（就近原则）。 构造方法 使用new 构造方法 创建一个新的对象。 构造方法是定义在Java类中的一个用来初始化对象的方法，构造方法与类同名且没有返回值。 无参构造方法的使用 main(): Telphone phone = new Telphone(); class Telphone: public Telphone() { System.out.println(\"Telphone Constractor\"); } 带参构造方法的使用 main(): Telphone phone2 = new Telphone(5.0f); class Telphone: public Telphone(float newScreen) { screen = newScreen; } 当没有指定构造方法时，系统会自动添加无参的构造方法。 当有指定构造方法，无论是有参、无参的构造方法，系统都不会自动添加无参的构造方法。 构造方法的重载：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择相应的方法。 构造方法不但可以给对象的属性赋值，还可以保证给对象的属性赋一个合理的值 // Tp.java package com.test pubilc class Tp { private float screen; public Tp() { System.out.println(\"com.test Tp无参构造方法执行了\"); } public Tp(float newScreen) { if (newScreen Java 中的 static 使用之静态变量 Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。当然，鉴于他作用的特殊性更推荐用类名访问~~ 使用 static 可以修饰变量、方法和代码块。 注意：静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收！ Java 中的 static 使用之静态方法 与静态变量一样，使用 static 修饰的方法，称为静态方法或类方法。比如之前使用的 main 方法就是静态方法。静态方法的使用如： 静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。 如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量 在普通成员方法中，则可以直接访问同类的非静态变量和静态变量 静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法 Java 中的 static 使用之静态初始化块 Java 中可以通过初始化块进行数据赋值 public class Hello { String name; // 定义一个成员变量 // 通过初始化块，为成员变量赋值 { name = \"hello\"; } } 在类的声明中，可以包含多个初始化块，当创建类的实例时，就会依次执行这些代码块。如果使用 static 修饰初始化块，就称为静态初始化块。 注意：静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量。 结果： 通过输出结果，我们可以看到，程序运行时静态初始化块最先被执行，然后执行普通初始化块，最后才执行构造方法。由于静态初始化块只在类加载时执行一次，所以当再次创建对象 hello2 时并未执行静态初始化块。 代码 package com.test2; public class HelloWorld { int num1; int num2; static int num3; public HelloWorld () { num1 = 91; System.out.println(\"通过构造方法为变量num1赋值\"); } { num2 = 74; System.out.println(\"通过初始化块为变量num2赋值\"); } static { num3 = 3; System.out.println(\"通过静态初始化块为静态变量num3赋值\"); } public static void main (String[] args) { HelloWorld h = new HelloWorld(); System.out.println(\"num1: \" + h.num1); System.out.println(\"num2: \" + h.num2); System.out.println(\"num3: \" + HelloWorld.num3); HelloWorld h2 = new HelloWorld(); } } 结果 通过静态初始化块为静态变量num3赋值 通过初始化块为变量num2赋值 通过构造方法为变量num1赋值 num1: 91 num2: 74 num3: 3 通过初始化块为变量num2赋值 通过构造方法为变量num1赋值 原课程地址 Java入门第二季 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-01 20:38:19 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/second-season/encapsulation.html":{"url":"pages/second-season/encapsulation.html","title":"面向对象特性：封装","keywords":"","body":"面向对象特性 三大特性：封装、继承、多态 封装 1、概念 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和方法。 2、好处 只能通过规定的方法访问数据 隐藏类的实例细节，方便修改和实现 3、封装的实现步骤 public class Hello { provite float screen; // getter public float getScreen() { return screen; } // setter public void setScreen(float newScreen) { screen = newScreen; } } java中的包 1、作用 管理Java文件 解决同名文件冲突 2、包的定义：package 包名 注意：必须放在Java源程序的第一行，包名间可以使用.号隔开，eg: com.test.HelloWorld // 例子：音乐类-MyClassMusic // music com.test.music.MyClassMusic // movie com.test.movie.MyClassMusic 3、系统中的包 java.(功能).(类) java.lang.(类) 包含java语言基础的类 java.util.(类) 包含java语言中各种工具类 java.io.(类) 包含输入、输出相关功能的类 4、包的使用 可以通过import关键字，在某个文件使用其它文件中的类。 import com.test.music.MyClass Java中，包的命名规范是全小写字母拼写 使用的时候不但可以加载某个包下面的所以文件 com.test.* 也可以加载某个具体包下的所以文件 com.test.music.* Java中的访问修饰符 class Telphone { private float screen = 5.0f; public float getScreen() { return screen; } publick void setScreen(float newScreen) { screen = newScreen; } // ... } 访问修饰符--可以修饰属性和方法的访问范围。 访问修饰符 本类 同包 子类 其他 private o - - - 默认 o o - - protected o o o - public o o o o Java中的this关键字 1、this关键字代表当前对象 this.属性 操作当前对象的属性 this.方法 调用当前对象的方法 2、封装对象的属性的时候，经常会使用this关键字 # Eclipse编辑器自动生成getter/setter 菜单栏 -> source -> Generate Getters and Setters ... # 指定需要生成getter或setter方法的属性 class Telphone { private float screen = 5.0f; public float getScreen() { return screen; } publick void setScreen(float screen) { this.screen = screen; } // ... } Java中的内部类 内部类（Inner Class）就是定义在另外一个类里的类。与之对应，包含内部类的类被称为外部类。 内部类的主要作用如下： 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类 内部类的方法可以直接访问外部类的所有数据，包括私有的数据 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便 内部类可分为以下几种： 成员内部类 静态内部类 方法内部类 匿名内部类 成员内部类 public class Outer { int outerNumber = 10; // 成员内部类 public class Inner { int innerNumber = 20; public void print () { System.out.println(\"Inner class's print method, and outerNumber=\" + outerNumber); } } public static void main (String[] args) { // 创建外部类对象 Outer ou = new Outer(); // 创建内部类对象 Inner in = ou.new Inner(); // 调用内部类对象方法 in.print(); } } 成员内部类的使用方法： Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如 public 、 protected 、 private 等 Inner 类中定义的 print() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性a 定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即： 内部类 对象名 = 外部类对象.new 内部类( ); 编译上面的程序后，会发现产生了两个 .class 文件 其中，第二个是外部类的 .class 文件，第一个是内部类的 .class 文件，即成员内部类的 .class 文件总是这样：外部类名$内部类名.class 注意： 外部类不能直接使用内部类的成员和方法 可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。 如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this关键字。如： 运行结果： 访问外部类中的b：1 访问内部类中的b：2 静态内部类 静态内部类是 static 修饰的内部类，这种内部类的特点是： 静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问 如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类(); 结果： 访问外部类中的b:1 访问内部类中的b:2 方法内部类 方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。 注意： [!WARNING|style:flat] 由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-01 20:38:19 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/second-season/inheritance.html":{"url":"pages/second-season/inheritance.html","title":"面向对象特性：继承","keywords":"","body":"继承 继承是类与类的一种关系，是一种is a的关系。 Java中的继承是单继承。 优点： 子类拥有父类的所有属性和方法。private修饰符的属性和方法除外。 复用父类的代码（代码复用）。 语法： class 子类 extends 父类 例子 // Animal.java class Animal { // 相当于JavaScript的constructor public Animal() { // ... } public name; public age; public void eat() { System.out.println(\"调用了Animal的eat方法\"); } } // Dog.java class Dog extends Animal { } // Initial.java class Initial { public static void main() { Dog dog = new Dog(); dog.name = \"DD\"; dog.age = 2; dog.eat(); } } 方法的重写 如果子类对继承父类的方法不满意，可以重写父类继承的方法，当调用方法时会优先调用子类的方法。 语法规则： 返回值类型，方法名，参数类型及个数都要与父类继承的方法相同，才叫方法的重写 继承的初始化顺序 初始化父类再初始化子类 先执行初始化对象中属性，再执行构造方法中的初始化 final 关键字 使用final关键字做标识有最终的含义 final可以修饰类、方法、属性和变量 final修饰类，则该类不允许被继承 final修饰方法，则该方法不允许被覆盖（重写） final修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值），或在构造方法中赋值（但只能选其一）。 final修饰变量，则该变量的值只能赋一次值，即变为常量。 final public class Animal { // ... } super 关键字 在对象的内部使用，可以代表父类对象。 访问父类的属性 super.age 访问父类的方法 super.eat() 例子 // Dog.java public void method() { System.out.println(super.age); } super的应用 子类的构造的过程当中必须调用其父类的构造方法。 如果子类的构造方法中没有显式调用父类的构造方法，则系统默认调用父类无参的构造方法。 如果显式的调用构造方法，必须在子类的构造方法的第一行。 // Dog.java public class Animal { // constructor public Animal() { super(); // 必须放在第一行 // ... } } 如果子类构造方法中既没有显式调用父类的构造方法，而父类又没有无参的构造方法，则编译就会出错。 Object类 Object类是所有类的父类，如果一个类没有使用extends关键字明确标识继承另外一个类，那么这个类默认继承Object类。 Object类中的方法，适合所有子类。 1、toString()方法 在Object类里面定义toString()方法的时候，返回的对象的哈希code码（对象地址字符串） 可以通过重写toString()方法表示出对象的属性 # Eclipse快速重写toString 菜单栏 -> source -> Generate toString 2、equals()方法 比较的是对象的引用是否指向同一块内存地址。 一般情况下比较两个对象时，比较他的值是否一致，所以要进行重写。 # Eclipse快速生成 source -> Generate hasCode() and equals()... © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-01 20:38:19 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/second-season/polymorphic.html":{"url":"pages/second-season/polymorphic.html","title":"面向对象特性：多态","keywords":"","body":"多态 对象的多种形态。引用多态、方法多态。 继承是多态实现的基础 引用多态 父类的引用可以指向本类的对象。 父类的引用可以指向子类的对象。 方法多态 创建本类对象时，调用的方法为本类方法。 创建子类对象时，调用的方法为子类重写的方法或者继承的方法。 // Animal.java package com.polymorphic; public class Animal { public void eat () { System.out.println(\"Animal has eat method.\"); } } // Dog.java package com.polymorphic; public class Dog extends Animal { // overwrite public void eat () { System.out.println(\"Dogs eat meat.\"); } } // Cat.java package com.polymorphic; public class Cat extends Animal { } // Initial.java package com.polymorphic; public class Initial { public static void main(String[] args) { /* * 引用多态/方法多态 */ // 父类的引用可以指向本类的对象 Animal obj1 = new Animal(); // 父类的引用可以指向子类的对象 Animal obj2 = new Dog(); Animal obj3 = new Cat(); // methods polymorphic obj1.eat(); obj2.eat(); obj3.eat(); /* * 引用类型转换 */ Dog dog = new Dog(); Animal animal = dog; // 自动类型提升，向上类型转换 // Warning // Dog dog2 = animal; // Type mismatch: cannot convert from Animal to Dog Dog dog2 = (Dog)animal; // 向下类型转换 强制类型转换 // error // Cat cat = (Cat)animal; // 编译时Cat类型(不会报错)，运行时Dog类型(抛出异常) // instanceof if (animal instanceof Cat) { Cat cat = (Cat)animal; } else { System.out.println(\"无法进行Cat类型转换\"); } } } 多态中的引用类型转换 向上类型转换（隐式/自动类型转换），是小类型到大类型的转换。 向下类型转换（强制类型转换），是大类型到小类型。容易发送数据溢出。 instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题。 package com.polymorphic; public class Initial { public static void main(String[] args) { /* * 引用多态/方法多态 */ // 父类的引用可以指向本类的对象 Animal obj1 = new Animal(); // 父类的引用可以指向子类的对象 Animal obj2 = new Dog(); Animal obj3 = new Cat(); // methods polymorphic obj1.eat(); obj2.eat(); obj3.eat(); /* * 引用类型转换 */ Dog dog = new Dog(); Animal animal = dog; // 自动类型提升，向上类型转换 // Warning // Dog dog2 = animal; // Type mismatch: cannot convert from Animal to Dog Dog dog2 = (Dog)animal; // 向下类型转换 强制类型转换 // error // Cat cat = (Cat)animal; // 编译时Cat类型(不会报错)，运行时Dog类型(抛出异常) // instanceof if (animal instanceof Cat) { Cat cat = (Cat)animal; } else { System.out.println(\"无法进行Cat类型转换\"); } } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-01 20:38:19 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/second-season/abstract.html":{"url":"pages/second-season/abstract.html","title":"Java中的抽象类","keywords":"","body":"Java中的抽象类 语法：使用abstract关键字修饰，则该类为抽象类。 应用场景： [!TIP|style:flat|label:Application Scenarios] 在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。（父类规定子类必须包含哪些方法，但不关心子类如何实现） 从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。 作用： 限制规定子类必须实现某些方法，但不关心实现细节。 使用规则： abstract 定义抽象类 abstract 定义抽象方法，只有声明，不需要实现 包含抽象方法的类是抽象类 抽象类中可以包含普通的方法，也可以没有抽象方法 抽象类不能直接创建，可以定义引用变量 [!WARNING|style:flat] 抽象方法没有方法体，以分号直接结束。 public abstract void call(); public abstract void message(); 例子 // Phone.java package com.phone; public abstract class Phone { public abstract void call(); public abstract void message(); } // CellPhone.java package com.phone; public class CellPhone extends Phone { @Override public void call() { // TODO Auto-generated method stub System.out.println(\"以前的手机，是通过键盘来打电话\"); } @Override public void message() { // TODO Auto-generated method stub System.out.println(\"以前的手机，是通过键盘来发短信\"); } } // SmartPhone.java package com.phone; public class SmartPhone extends Phone { @Override public void call() { // TODO Auto-generated method stub System.out.println(\"智能手机，是通过语音来打电话\"); } @Override public void message() { // TODO Auto-generated method stub System.out.println(\"智能手机，是通过语音来发短信\"); } } // Initial.java package com.phone; public class Initial { public static void main(String[] args) { // TODO Auto-generated method stub Phone tel1 = new CellPhone(); tel1.call(); tel1.message(); Phone tel2 = new SmartPhone(); tel2.call(); tel2.message(); } } 思考题： 现有Shape图形类，用Rectangle矩形和Circle圆形子类，求图形的周长和面积 // Shape.java package com.shape; public abstract class Shape { public abstract float getPerimeter(); public abstract float getArea(); } // Circle.java package com.shape; public class Circle extends Shape { final float PI = 3.1415926f; float radius; @Override public float getPerimeter() { // TODO Auto-generated method stub return this.checkRadius() ? 2 * PI * this.radius : 0; } @Override public float getArea() { // TODO Auto-generated method stub return this.checkRadius() ? PI * this.radius * this.radius : 0; } private boolean checkRadius() { if (this.radius == 0) { System.out.println(\"未设置圆半径\"); return false; } return true; } } // Rectangle.java package com.shape; public class Rectangle extends Shape { public float width; public float height; @Override public float getPerimeter() { if (this.width == 0 || this.height == 0) { System.out.println(\"未设置矩形的长或宽\"); return 0; } // TODO Auto-generated method stub return (this.width + this.height) * 2; } @Override public float getArea() { // TODO Auto-generated method stub return this.width * this.height; } } // Initial.java package com.shape; public class Initial { public static void main(String[] args) { // TODO Auto-generated method stub Rectangle rect = new Rectangle(); rect.width = 20.0f; rect.height = 10.0f; System.out.println(\"长方形边长为：\" + rect.getPerimeter() + \"厘米\"); System.out.println(\"长方形面积为：\" + rect.getArea() + \"平方厘米\"); // circle Circle circle = new Circle(); circle.radius = 20.0f; System.out.println(\"圆周为：\" + circle.getPerimeter() + \"厘米\"); System.out.println(\"圆面积为：\" + circle.getArea() + \"平方厘米\"); } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-01 20:38:19 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/second-season/interface.html":{"url":"pages/second-season/interface.html","title":"接口","keywords":"","body":"接口 接口可以理解为一种特殊的类，由全局常量和公共的抽象方法所组成。 [!TIP|style:flat|label:Concept] 类是一种具体实现，而接口定义了某一批类所需要遵守的 规范，接口不关心这些类的内部数据，及类里方法的实现细节，它只规定这些类必须提供某些方法。 语法： [修饰符] abstract interface 接口名称 [extends 父接口1, 父接口2...] { 零到多个常量定义... 零到多个抽象方法的定义... } 关键字abstract可以省略，系统自动默认会添加abstract关键字。 接口就是用来被继承、被实现的，修饰符一般建议用public [!WARNING|style:flat] 不能使用private和protected修饰接口 接口定义 常量： 接口中的属性是常量，即使定义时不添加 public static final 修饰符，系统也会自动加上。 方法： 接口中的方法只能是抽象方法，即使定义时不添加 public abstract 修饰符，系统也会自动加上。 使用接口 一个类可以实现一个或多个接口，实现接口使用implements关键字。Java中一个类只能继承一个父类，是不够灵活的，通过实现多个接口来做补充（弥补）。 继承父类实现的接口语法： [修饰符] class 类名 extends 父类 implements 接口1, 接口2... { // 类体部分 // 如果继承了抽象类，则必须实现继承的抽象方法 // 如果遵守了某个接口，则必须实现接口中的抽象方法 } [!WARNING|style:flat] 如果继承了抽象类，则必须实现继承的抽象方法 如果遵守了某个接口，则必须实现接口中的抽象方法 如果要继承父类，则继承父类必须在实现接口以前，即extends与 implements不能交换位置。 // new -> interface // IPlayGame.java package com.phone; public interface IPlayGame { public void playGame(); } // 系统会默认添加abstract关键字 //public abstract interface IPlayGame { // public abstract void playGame(); //} // SmartPhone.java package com.phone; public class SmartPhone extends Phone implements IPlayGame { @Override public void call() { // TODO Auto-generated method stub System.out.println(\"智能手机，是通过语音来打电话\"); } @Override public void message() { // TODO Auto-generated method stub System.out.println(\"智能手机，是通过语音来发短信\"); } @Override public void playGame() { // TODO Auto-generated method stub System.out.println(\"智能手机具有了玩游戏的功能\"); } } // Psp.java package com.phone; public class Psp implements IPlayGame { @Override public void playGame() { // TODO Auto-generated method stub System.out.println(\"PSP具有了玩游戏的功能\"); } } // Initial.java package com.phone; public class Initial { public static void main(String[] args) { // TODO Auto-generated method stub Phone tel1 = new CellPhone(); tel1.call(); tel1.message(); Phone tel2 = new SmartPhone(); tel2.call(); tel2.message(); // Interface IPlayGame ip1 = new SmartPhone(); ip1.playGame(); IPlayGame ip2 = new Psp(); ip2.playGame(); } } 匿名内部类 匿名内部类：就是没有名称的内部类。 接口在使用过程当中，还经常与匿名内部类配合使用。 多用于关注实现，而不关注实现类的名称。 语法： Interface i = new Interface() { public void method() { System.out.println(\"匿名内部类实现接口的方式\"); } } package com.phone; public class Initial { public static void main(String[] args) { // TODO Auto-generated method stub Phone tel1 = new CellPhone(); tel1.call(); tel1.message(); Phone tel2 = new SmartPhone(); tel2.call(); tel2.message(); // Interface IPlayGame ip1 = new SmartPhone(); ip1.playGame(); IPlayGame ip2 = new Psp(); ip2.playGame(); // 匿名内部类实现接口 IPlayGame ip3 = new IPlayGame() { @Override public void playGame() { // TODO Auto-generated method stub System.out.println(\"匿名内部类实现接口的方式\"); } }; ip3.playGame(); // 直接new // Android中使用较为频繁 new IPlayGame() { @Override public void playGame() { // TODO Auto-generated method stub System.out.println(\"直接使用new，实现匿名内部类接口\"); } }.playGame(); } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-01 20:38:19 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/second-season/UML.html":{"url":"pages/second-season/UML.html","title":"UML(Unified Modeling Language)","keywords":"","body":"UML Unified Modeling Language（UML），统一建模语言或标准建模语言。 是一个支持模型化和软件系统开发的图形化语言。 为软件开发的所以阶段提供模型化和可视化支持。 UML图示 UML 2.2一共定义了14中图示（diagrams）。 参考资料： https://www.cnblogs.com/Ph-one/p/7650624.html https://www.eclipse.org/modeling/mdt/downloads/?project=uml2 https://www.cnblogs.com/silent2012/archive/2011/09/07/2169946.html 常用UML图 用例图（The Use Case Diagram） [!TIP|style:flat|label:The Use Case Diagram] 用例图能够以可视化的方式，表达系统如何满足所收集的业务规则，以及特定的用户需求等信息。 序列图（The Sequence Diagram） [!TIP|style:flat|label:The Sequence Diagram] 序列图用于安装交互发生的一系列顺序，显示对象之间的这些交互。 类图（The Class Diagram） [!TIP|style:flat|label:The Class Diagram] UML类图、业务逻辑和所有支持结构一同被用于定义全部的代码结构。 UML建模工具 Microsoft Office Visio、Rational Rose、PowerDesign三种建模工具应用最广。 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-01 20:48:15 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/third-season/exception.html":{"url":"pages/third-season/exception.html","title":"异常与异常处理","keywords":"","body":"异常与异常处理 字面意思：有异于常态，和正常情况不一样，有错误出现。 程序中：阻止当前方法或作用域正常运行的情况，称之为异常。 [!TIP|style:flat|Exception] 异常指的是在程序运行过程中发生的异常事件，通常是由外部问题（如硬件错误、输入错误）所导致的。在Java等面向对象的编程语言中异常属于对象。 导致的问题： 1、程序得不到正常的运行，不能正常退出 2、导致用户数据丢失 3、程序运行的资源得不到有效的释放 异常处理作用： 1、对异常正确的处理，能将异常提示给编程人员或者是用户 2、使已中断的程序，以适当的方式继续运行或退出，并且可以保存用户的当前操作，或数据回滚 3、最后再把占用的资源释放掉 Throwable类 主要有两个儿子Error与Exception，即Error与Exception类继承Throwable类 Error [!TIP|style:flat|label:Error] 系统错误，内存溢出 虚拟机错误 VirtualMachineError 线程死锁 ThreadDeath 它的出现，即意味着程序挂了，即程序终结者 好比工厂停水/停电/机器挂了 Exception [!TIP|style:flat|label:Exception] 编码、环境、用户操作输入出现问题 主要有 RuntimeException 称之为非检查异常 其他异常称之为：检查异常 CheckException 非检查异常 RuntimeException 引起RuntimeException的原因： 1、引用了一个空对象或方法。空指针异常 NullPointerException String str = null; System.out.println(str.length()); 2、数组访问越界。数组下标越界异常 ArrayIndexOutOfBoundsException int[] arr = { 1, 2, 3 } for (int i = 0; i 3、错误的类型转换。类型转换异常 ClassCastException class Animal {} class Dog extends Animal {} class Cat extends Animal {} public class Test { public static void main (String[] args) { Animal a1 = new Dog(); Animal a2 = new Cat(); Dog d1 = (Dog)a1; Dog d2 = (Dog)a2; } } 4、运算异常，整数去整除零。算术异常 ArithmeticException int a = 12; int b = 0; System.out.println(a / b); 5、等等... [!TIP|style:flat] 运行时异常 会由Java虚拟机自动抛出，并自动捕获。 运行时异常的出现，多数情况下说明代码本身出了问题，应该从逻辑上去改进代码。 检查异常 CheckException 比如：文件异常 IOException，SQl异常 SQLException等等很多，需要开发人员自己捕获及处理。 异常处理 try-catch, try-catch-finally © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-01 22:50:14 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "}}