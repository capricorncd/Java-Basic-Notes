{"./":{"url":"./","title":"Introduction","keywords":"","body":"Java 教程笔记 Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。 文档：https://capricorncd.github.io/Java-Notes/ 目录 Java基础第一季 Java发展历程、Java平台应用、JVM/JDK/JRE、开发环境搭建 变量与常量 运算符 流程控制语句 数组 方法 Java基础第二季 类和对象 封装 继承 多态 Java中的抽象类 接口Interface UML Java基础第三季 异常与异常处理 异常抛出及自定义异常 Java 中的字符串 thread-safe 线程安全 包装类 Date和SimpleDateFormat类 Calendar类的应用 Math类 文档：https://capricorncd.github.io/Java-Notes/ © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-09 22:56:30 "},"pages/first-season/java.html":{"url":"pages/first-season/java.html","title":"Java","keywords":"","body":"Java Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。 Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。 Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。 Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等 Java发展历程 1995由Sun公司推出，2009被Oracle收购。 Java平台应用 核心概念：JVM/JDK/JRE [!TIP|label:JVM|style:flat] Java Virtual Machine [!TIP|label:JDK|style:flat] Java Development Kit (Java开发工具包) [!TIP|label:JRE|style:flat] Java Runtime Environment (Java运行时环境) Java 开发环境搭建 1、安装JDK https://www.oracle.com/technetwork/java/javase/downloads/index.html JDK8 https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html [!TIP|style:flat] Java库文件，以 .jar 结尾 2、window 10 配置环境变量（系统变量） # 配置JDK安装路径 JAVA_HOME C:\\Program Files\\Java\\jdk1.8.0_172 # 配置类库文件的位置 CLASSPATH .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar # 配置JDK命令文件的位置 path C:\\ProgramFiles\\Java\\jdk1.8.0_172\\bin C:\\Program Files\\Java\\jdk1.8.0_172\\bin\\jre\\bin 3、Mac 直接装jdk-8u201-macosx-x64.dmg就可以了。 使用工具开发Java程序 HelloWorld.java public class HelloWorld { public static void main(String[] args) { System.out.println(\"Welcome to Java world.\"); } } 使用bash，找到文件路径，执行 javac HelloWorld.java 此时，会在当前位置生产一个HelloWorld.class的字节码文件。 # 执行字节码文件，注意不能跟后缀名.class java HelloWorld # Welcome to Java world. 使用IDE开发 集成开发环境（IDE）是一类软件 将程序开发环境和程序调试环境集合在一起，提高开发效率。 Eclipse 开源免费的。下载地址 https://www.eclipse.org/downloads/ MyEclipse MyEclipse是对Eclipse的扩展，是一个十分优秀的用于开发Java、JavaEE的Eclipse插件集合。 https://www.myeclipsecn.com 开发流程 以Eclipse为例 1 创建Java项目 file -> New -> Java Project # Project name: hello 2 创建程序包 # src 目录 New -> Package # com.hello 3 编写Java源程序 com.hello -> New -> Class > Name: HelloTest IDE自动生成：HelloTest.java package com.hello; public class HelloTest { } [!WARNING|style:flat|label:注意] 类名 class HelloTest 一定要与文件名 HelloTest.java 相同。 如下图： 4 运行Java程序 代码编辑拦，空白处鼠标右键 -> Run As -> Java Application ... 或者点击编辑器左上角的\"播放\"图标，run ... 程序的移植 从公司拷回屋里继续写... 拷贝项目代码 -> 到家，开电脑，打开软件 -> File -> Import -> General/Existing Project into Workspace -> Next -> Select root directory: [Broser] -> 找到文件 -> Finish 来自巨人的经验 多练、多问、自己动手，调试错误、复习和总结。 学虽容易，学好不易，且学且珍惜。 原教程出处 https://www.imooc.com/learn/85 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-04 22:15:58 "},"pages/first-season/variable-and-constant.html":{"url":"pages/first-season/variable-and-constant.html","title":"变量与常量","keywords":"","body":"变量与常量 Java关键字 Java 关键字是区分大小写 Java标识符 标识符就是用于给 Java 程序中变量、类、方法等命名的符号。 使用标识符时，需要遵守几条规则： 1、标识符可以由字母、数字、下划线（_）、美元符（$）组成，但不能包含 @、%、空格等其它特殊字符，不能以数字开头。譬如：123name 就是不合法。 2、标识符不能是 Java 关键字和保留字（ Java 预留的关键字，以后的升级版本中有可能作为关键字），但可以包含关键字和保留字。如：不可以使用 void 作为标识符，但是 Void 可以。 3、标识符是严格区分大小写的。 4、标识符的命名最好能反映出其作用，做到见名知意。 变量 在 Java 中，我们通过三个元素描述变量：变量类型、变量名以及变量值。 int a = 30; String b = \"this is String\"; 通常： 1、变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 createUserInfo。 2、变量命名时，尽量简短且能清楚的表达变量的作用，做到见名知意。如：定义变量名 studentName 保存“学生姓名”信息。 3、Java 变量名的长度没有限制，但 Java 语言是区分大小写的，所以price和Price 是两个完全不同的变量！ public class HelloWorld { public static void main(String[] args) { int hobby = 9999; System.out.println(hobby); } } Java中的数据类型 Java 语言是一种强类型语言。通俗点说就是，在 Java 中存储的数据都是有类型的，而且必须在编译时就确定其类型。 Java 中有两类数据类型： [!WARNING|style:flat|label:注意] 在Java里，基本数据类型 变量存的是 数据本身，而 引用类型 变量存的是保存数据的 空间地址。 数据类型 说明 字节 应用 示例 int 整型 4 整数，如年龄/个数等 int age=21; double 双精度浮点型 8 小数，如商品价格/成绩平均分等 double price=21.5; float 单精度浮点型 4 小数，如身高等 float height=180.3f; char 字符型 2 单个字符，如性别男/女 char gander='男'; boolean 布尔型 1 表示真true或假false boolean flag=true; [!TIP|style:flat] float变量赋值时，在数值后面添加字母 f。 char变量赋值时，使用单引号 '。 Java中变量的使用规则 Java 中的变量需要先声明后使用 变量使用时，可以声明变量的同时进行初始化 变量中每次只能赋一个值，但可以修改多次 main 方法中定义的变量必须先赋值，然后才能输出 String a; System.out.println(a); // error [!WARNING|style:flat|label:注意] 虽然语法中不会提示错误，但在实际开发中，变量名不建议使用中文，容易产生安全隐患。譬如后期跨平台操作时出现乱码等等。 Java中的自动类型转换 自动类型转换: int a = 89; double b = a; System.out.println(b); // 89.0 自动类型转换是需要满足特定的条件: 1、目标类型能与源类型兼容，如 double 型兼容 int 型，但是 char 型不能兼容 int 型。 2、目标类型大于源类型，如 double 类型长度为 8 字节， int 类型为 4 字节，因此 double 类型的变量里直接可以存放 int 类型的数据，但反过来就不可以。 Java中的强制类型转换 double average = 74.9; int average2 = (int)average; System.out.println(average); // 74.9 System.out.println(average2); // 74 [!WARNING|style:flat|label:注意] 强制类型转换可能会造成数据的丢失 Java常量的应用 语法 final 常量名 = 值; 程序中使用常量可以提高代码的可维护性。 常量名一般使用大写字符。 Java中使用注释 在编写程序时，经常需要添加一些注释，用以描述某段代码的作用。 一般来说，对于一份规范的程序源代码而言，注释应该占到源代码的 1/3 以上。因此，注释是程序源代码的重要组成部分。 Java 中注释有三种类型：单行注释、多行注释、文档注释。 package com.test /** * 这是文档注释 * @author authorName * @version v1.0.0 */ public class TestDemo { /* * 这是多行注释 * 可以包含多行内容 */ public static void main(String[] args) { // 这是单行注释 System.out.println(\"Hello World\"); } } 我们可以通过 javadoc 命令从文档注释中提取内容，生成程序的 API 帮助文档。 javadoc -d doc TestDemo.java 使用文档注释时还可以使用 javadoc 标记，生成更详细的文档信息： @author 标明开发该类模块的作者 @version 标明该类模块的版本 @see 参考转向，也就是相关主题 @param 对方法中某参数的说明 @return 对方法返回值的说明 @exception 对方法可能抛出的异常进行说明 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 20:52:16 "},"pages/first-season/operator.html":{"url":"pages/first-season/operator.html","title":"运算符","keywords":"","body":"运算符 算术运算符 赋值运算符 比较运算符 逻辑运算符 条件运算符 算术运算符 算术运算符主要用于进行基本的算术运算，如加法、减法、乘法、除法等。 赋值运算符 赋值运算符是指为变量或常量指定数值的符号。如可以使用 “=” 将右边的表达式结果赋给左边的操作数。 比较运算符 比较运算符用于判断两个数据的大小，例如：大于、等于、不等于。比较的结果是一个布尔值（ true 或 false ）。 1、>、、>=、 只支持左右两边操作数是数值类型 2、==、!= 两边的操作数既可以是数值类型，也可以是引用类型 逻辑运算符 逻辑运算符主要用于进行逻辑运算。Java 中常用的逻辑运算符如下表所示： 我们可以从“投票选举”的角度理解逻辑运算符： 1、与：要求所有人都投票同意，才能通过某议题 2、或：只要求一个人投票同意就可以通过某议题 3、非：某人原本投票同意，通过非运算符，可以使其投票无效 4、异或：有且只能有一个人投票同意，才可以通过某议题 当使用逻辑运算符时，我们会遇到一种很有趣的“短路”现象。 譬如：( one > two ) && ( one two 运行结果为 false , 则系统就认为已经没有必要执行右侧的 one 同理，在( one > two ) || ( one 条件运算符 条件运算符（ ? : ）也称为 “三元运算符”。 语法： 布尔表达式 ？表达式1 ：表达式2 运算符的优先级 所谓优先级，就是在表达式中的运算顺序。 优先级 运算符 1 () 2 ! +正 -负 ++ -- 3 * / % 4 +加 -减 5 >= 6 == != 7 ^ 8 && 9 10 ? :三元运算符 11 = += -= *= /= %= 级别为 1 的优先级最高，级别 11 的优先级最低。 ( 11+ 3* 8 ) / 4 % 3; // 2 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 23:52:20 "},"pages/first-season/flow-control-statement.html":{"url":"pages/first-season/flow-control-statement.html","title":"流程控制语句","keywords":"","body":"流程控制语句 if, if else if (BooleanConditionalExpression) { // do something } else { // do something } if (BooleanConditionalExpression1) { // do something } else if (BooleanConditionalExpression2) { // do something } else { // do something } switch switch (Expression) { case Value1: // do something break; case Value1: // do something break; default: // do something } while int i = 1; while (i for for (循环变量初始化; 循环条件; 循环变量变化) { // 循环操作 } 执行过程： 1、执行循环变量初始化部分，设置循环的初始状态，此部分在整个循环中只执行一次 2、进行循环条件的判断，如果条件为 true ，则执行循环体内代码；如果为 false ，则直接退出循环 3、执行循环变量变化部分，改变循环变量的值，以便进行下一次条件判断 4、依次重新执行、、，直到退出循环 特点： 相比 while 和 do...while 语句结构更加简洁易读 注意： 1、for 关键字后面括号中的三个表达式必须用 “;” 隔开，三个表达式都可以省略，但 “;” 不能省略。 a. 省略“循环变量初始化”，可以在 for 语句之前由赋值语句进行变量初始化操作，如: int i = 0; for (; i b. 省略“循环条件”，可能会造成循环将一直执行下去，也就是我们常说的“死循环”现象，如: for (int i = 0; ; i++) { // do something } 在编程过程中要避免“死循环”的出现，因此，对于上面的代码可以在循环体中使用 break 强制跳出循环。 c. 省略“循环变量变化”，可以在循环体中进行循环变量的变化，如： for (int i = 0; i 2、for 循环变量初始化和循环变量变化部分，可以是使用 “,” 同时初始化或改变多个循环变量的值，如： for (int i = 1, j = 5; i 代码中，初始化变量部分同时对两个变量 i 和 j 赋初值，循环变量变化部分也同时对两个变量进行变化。 3、循环条件部分可以使用逻辑运算符组合的表达式，表示复杂判断条件，但一定注意运算的优先级，如： for (int i = 1; i 代码中，必须同时满足变量 i 小于 10 ，并且 i 不等于 5 时才会进行循环，输出变量 i 的值。 break for (int i = 0; i continue for (int i = 0; i 编程题 /* * 为指定成绩加分，直到分数大于等于 60 为止， * 输出加分前和加分后的成绩，并统计加分的次数 */ Test1.java package com.test1; import java.util.Scanner; /* * 为指定成绩加分，直到分数大于等于 60 为止， * 输出加分前和加分后的成绩，并统计加分的次数 */ /* * 使用Scanner工具类来获取用户输入的成绩信息 * Scanner类位于java.util包中，使用时需要导入 * 步骤： * 1.导入java.util.Scanner * 2.创建Scanner对象 * 3.接收并保存用户输入的值 */ public class Test1 { public static void main(String[] args) { // create Scanner Object Scanner input = new Scanner(System.in); // notice // println输出后会换行，print不会 System.out.print(\"请输入考试成绩（整数）：\"); // score // get user input score, and save to variable int score = input.nextInt(); // count int count = 0; System.out.println(\"origin score: \" + score); while (score /* * 求3个班级，各4名学生的平均成绩 */ Test2.java package com.test2; import java.util.Scanner; /* * 求3个班级，各4名学生的平均成绩 */ public class Test2 { public static void main(String[] args) { Scanner input = new Scanner(System.in); int classNum = 3; int studentNum = 4; int score; double sum; double avgs; for (int i = 1; i © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 23:53:22 "},"pages/first-season/array.html":{"url":"pages/first-season/array.html","title":"数组","keywords":"","body":"数组 int[] scores = { 1, 2, 3, 4, 5, 6, 7 } System.out.println(scores[2]); // 3 声明数组 语法： 数据类型[ ] 数组名； // 或者 数据类型 数组名[ ]； 其中，数组名可以是任意合法的变量名，如： // 存储学生成绩的数组，类型为整型 int[] scores; // 存在身高的数组，类型为浮点型 double height[]; // 存储学生姓名的数组，类型为字符串 String[] names; 分配空间 简单地说，就是指定数组中最多可存储多少个元素 语法： 数组名 = new 数据类型 [ 数组长度 ]; 其中，数组长度就是数组中能存放元素的个数，如： scores = new int[5]; height = new double[5]; names = new String[5]; 也可以将上面的两个步骤合并，在声明数组的同时为它分配空间 int[] scores = new int[5]; 赋值 scores[0] = 100; scores[1] = 99; 处理数组中数据 System.out.println(scores[1]); // 99 同时声明数组、分配空间和赋值： int[] scores = {89, 90, 100, 78}; public class HelloWorld { public static void main(String[] args) { // 定义一个长度为5的字符串数组，保存考试科目信息 String[] subjects = new String[5]; // 分别为数组中的元素赋值 subjects[0] = \"Oracle\"; subjects[1] = \"PHP\"; subjects[2] = \"Linux\"; subjects[3] = \"Java\"; subjects[4] = \"HTML\"; System.out.println(\"数组中第4个科目为：\" + subjects[3]); } } 例子： // error: // Cannot define dimension expressions when an array initializer is provided int[ ] score = new int[ 4 ] { 90, 12, 34, 77 }; // error: // Variable must provide either dimension expressions // or an array initializer int[ ] score = new int[ ]; // right int score[ ] = new int[ ] { 34, 90, 87, 54, 24 }; 循环操作 int[] arr = { 34, 53, 98, 23}; for (int i = 0; i 获取数组的长度语法 数组名.length 数组下标的范围是 0 至 数组长度-1 ，如果越界访问，就会报错。 // Array.java Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 4 at com.array.Array.main(Array.java:15) 练习： 输出数组中的最大值、最小值和平均值 public class Array { public static void main(String[] args) { // 定义一个整型数组，并赋初值 int[] nums = new int[] { 61, 23, 4, 74, 13, 148, 20 }; int max = nums[0]; // 假定最大值为数组中的第一个元素 int min = nums[0]; // 假定最小值为数组中的第一个元素 double sum = 0;// 累加值 double avg = 0;// 平均值 for (int i = 0; i 0 && nums[i] > max) { max = nums[i]; } // 如果当前值小于min，则替换min的值 if (i > 0 && nums[i] 使用 Arrays 类操作 Java 中的数组 Arrays 类是 Java 中提供的一个工具类，在 java.util 包中。该类中包含了一些方法用来直接操作数组，比如可直接实现数组的排序、搜索等 排序 sort() // 语法： Arrays.sort(数组名); public class Array { public static void main(String[] args) { // 定义一个整型数组，并赋初值 int[] nums = new int[] { 61, 23, 4, 74, 13, 148, 20 }; Arrays.sort(nums); System.out.println(\"排序后的首尾数为：\" + nums[0] + \", \" + nums[nums.length - 1]); System.out.println(\"toString: \" + Arrays.toString(nums)); } } 将数组转换为字符串 toString() // 语法： Arrays.toString(数组名); foreach foreach 并不是 Java 中的关键字，是 for 语句的特殊简化版本，在遍历数组、集合时， foreach 更简单便捷。 [!TIP|style:flat|label:语法] for (元素类型 元素变量 : 遍历对象) { // do something } for (int i : nums) { System.out.println(\"print by foreach: \" + i); } 二维数组 声明数组/分配空间 数据类型[][] 数组名 = new 数据类型[行数][列数]; 或 数据类型[][] 数组名; 数组名 = new 数据类型[行数][列数]; CODE Array.java package com.array; import java.util.Arrays; /* public class Array { public static void main(String[] args) { // right: int score[] = new int[]{45, 56, 76, 23}; // error: // Cannot define dimension expressions // when an array initializer is provided // int score[] = new int[4]{45, 56, 76, 23}; // error: // Variable must provide either dimension expressions // or an array initializer // int[ ] score = new int[ ]; System.out.println(score[4]); } } */ /* public class Array { public static void main(String[] args) { // 定义一个整型数组，并赋初值 int[] nums = new int[] { 61, 23, 4, 74, 13, 148, 20 }; int max = nums[0]; // 假定最大值为数组中的第一个元素 int min = nums[0]; // 假定最小值为数组中的第一个元素 double sum = 0;// 累加值 double avg = 0;// 平均值 for (int i = 0; i 0 && nums[i] > max) { max = nums[i]; } // 如果当前值小于min，则替换min的值 if (i > 0 && nums[i] Test.java package com.array; import java.util.Arrays; /* * 创建指定长度的 int 型数组， * 并生成 100 以内随机数为数组中的每个元素赋值， * 然后输出数组 */ //public class Test { // public static void main(String[] args) { // Test ts = new Test(); // // create array // int[] arr = ts.createArray(8); // // System.out.println(Arrays.toString(arr)); // } // // public int[] createArray(int length) { // int[] arr = new int[length]; // for (int i = 0; i = 3) break; if (scores[i] >= 0 && scores[i] arr[i]) { temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } return arr; } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 21:53:10 "},"pages/first-season/function.html":{"url":"pages/first-season/function.html","title":"方法","keywords":"","body":"方法 语法 访问修饰符 返回值类型 方法名(参数列表) { 方法体 } 访问修饰符： 方法允许被访问的权限范围，可以是 public、protected、private 甚至可以省略。其中 public 表示该方法可以被其他任何代码调用。 返回值类型： 方法返回值的类型，如果方法不返回任何值，则为 void；如果有返回值，则需要指定返回值的类型，并且在方法体中使用 return 语句返回值。 方法名： 定义的方法的名字，必须使用合法的标识符。 参数列表： 传递给方法的参数列表，参数可以有多个，多个参数间以逗号隔开，每个参数由参数类型和参数名组成，以空格隔开。 根据方法是否带参、是否带返回值，可将方法分为四类: Ø 无参无返回值方法 Ø 无参带返回值方法 Ø 带参无返回值方法 Ø 带参带返回值方法 public void print(String str) { System.out.println(str); } 例子 // Func.java public class Func { // 定义print方法 public void print(String str) { System.out.println(str); } public static void main(String[] args) { // 创建Func对象 Func fn = new Func(); // 调用print方法 fn.print(\"Hello world\"); } } 无参带返回值方法 public int sum() { int a = 1; int b = 3; return a + b; } 1、如果方法的返回类型为 void ，则方法中不能使用 return 返回值！ 2、方法的返回值最多只能有一个，不能返回多个值。 3、方法返回值的类型必须兼容，例如，如果返回值类型为 int ，则不能返回 String 型值。 带参无返回值方法 public int sum(int a, int b) { System.out.println(a + b); } 1、调用带参方法时，必须保证实参的数量、类型、顺序与形参一一对应 2、调用方法时，实参不需要指定数据类型 3、方法的参数可以是基本数据类型，如 int、double 等，也可以是引用数据类型，如 String、数组等 4、当方法参数有多个时，多个参数间以逗号分隔。 带参有返回值方法 public int sum(int a, int b) { return a + b; } Java 中方法的重载 [!TIP|style:flat|label:什么是方法的重载呢？] 如果同一个类中包含了两个或两个以上方法名相同、方法参数的个数、顺序或类型不同的方法，则称为方法的重载，也可称该方法被重载了。如下所示 4 个方法名称都为 show ，但方法的参数有所不同，因此都属于方法的重载： // 无参数方法 public void show() { System.out.println(\"not arguments\"); } // 重载show方法，一个字符串参数 public void show(String name) { System.out.println(\"argument name: \" + name); } // 重载show方法，两个参数 public void show(String name, int age) { System.out.println(name + \" is \" + age + \" years old\"); } // 重载show方法，两个参数顺序不同 public void show(int age, String name) { System.out.println(\"The \" + age + \"-year-old people is \" + name + \".\"); } [!TIP|style:flat|label:如何区分调用的是哪个重载方法呢？] 当调用被重载的方法时， Java 会根据参数的个数和类型来判断应该调用哪个重载方法，参数完全匹配的方法将被执行。如： public static void main(String[] args) { Func fn = new Func(); fn.show(); // 调用无参数的show方法 fn.show(\"Juny\"); // 调用带有一个参数的show方法 fn.show(\"Juny\", 15); // 调用带有字符串+整型参数的show方法 } 判断方法重载的依据： 1、必须是在同一个类中 2、方法名相同 3、方法参数的个数、顺序或类型不同 4、与方法的修饰符或返回值没有关系 Test.java package com.test; import java.util.Arrays; /* * 创建指定长度的 int 型数组， * 并生成 100 以内随机数为数组中的每个元素赋值， * 然后输出数组 */ public class Test { public static void main(String[] args) { Test ts = new Test(); // create array int[] arr = ts.createArray(8); System.out.println(Arrays.toString(arr)); } public int[] createArray(int length) { int[] arr = new int[length]; for (int i = 0; i CODE Func.java package com.array; public class Func { public void print(String str) { System.out.println(str); } public int sum() { int a = 1; int b = 3; return a + b; } public static void main(String[] args) { Func f = new Func(); f.print(\"Hello world\" + f.sum()); } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 21:56:18 "},"pages/second-season/class-and-object.html":{"url":"pages/second-season/class-and-object.html","title":"类与对象","keywords":"","body":"类和对象 面向对象 1、对象的概念 2、什么是面向对象 3、类 4、什么是对象的属性 5、什么是对象的方法 6、类与对象的关系/区别 对象的概念 万物皆对象，客观存在的事物皆为对象。 什么是面向对象 人 -> 关注 -> 事物信息 类 类是模子，确定对象将会拥有的特征（属性）和行为（方法）。 类的特点：类是对象的类型，具有相同属性和方法的一组对象的集合。 什么是对象的属性 属性：对象具有的各种特征，每个对象的每个属性都拥有特定值。 什么是对象的方法 方法：对象执行的操作。 类与对象的关系/区别 类是抽象的概念，仅仅是模板，比如说\"手机\"； 对象是一个你能够看得到，摸得着的具体实体。 \"手机\"类 对象 特征（属性）屏幕/CPU/内存 华为, 小米... 行为（方法）打电话/发短信 华为, 小米... 类的定义 类的重要性：所有Java程序都以 类class 为组织单元。 类的组成：属性和方法。 定义一个类的步骤： 定义类名，编写类的属性，编写类的方法 语法 public class 类名 { // 定义属性部分（成员变量） 类型 属性1; 类型 属性2; ... 类型 属性n; // 定义方法部分 方法1; 方法2; ... 方法n; } 例子 // Telphone.java package com.phone; // 1. 定义一个类Telphone public class Telphone { // 2. 属性（成员变量） float screenSize; float cpu; float memory; // 3. 方法 干什么 vodi call() { System.out.println(\"Telphone有打电话的功能\"); } vodi sendMessage() { System.out.println(\"Telphone有发短信的功能\"); } } 使用对象 使用对象的步骤： 1、创建对象 类名 对象名 = new 类名(); Telphone phone = new Telphone(); 2、使用对象 引用对象的属性：对象名.属性 // 给screenSize属性赋值5 phone.screenSize = 5; 引用对象的方法：对象名.方法名() // 调用sendMessage()方法 phone.sendMessage(); 完整例子： com.test/Telphone.java package com.test; public class Telphone { float screenSize; float cpu; float memory; void call() { System.out.println(\"call\"); } void sendMessage() { System.out.println(\"screenSize: \" + screenSize + \", cup: \" + cpu + \", memory: \" + memory); } } com.test/useTelphone.java package com.test; public class useTelphone { public static void main(String[] args) { // TODO Auto-generated method stub Telphone phone = new Telphone(); phone.sendMessage(); // 赋值 phone.screenSize = 5.4f; phone.cpu = 1.4f; phone.memory = 4.0f; phone.sendMessage(); } } 成员变量和局部变量 1、成员变量：在 类 中定义，用了描述对象将要有什么。 2、局部变量：在类的 方法 中定义，在方法中临时保存数据。 区别 成员变量 局部变量 作用域 在整个类内部都是可见的 仅限于定义它的方法中 初始值 Java会给成员变量一个初始值，调用时可以不赋值 不会赋初始值，调用前必须赋值 同一个方法中，不允许有同名局部变量。 两类变量同名时，局部变量具有更高的优先级（就近原则）。 构造方法 1、使用new 构造方法 创建一个新的对象。 2、构造方法是定义在Java类中的一个用来初始化对象的方法，构造方法与类同名且没有返回值。 3、无参构造方法的使用 main(): Telphone phone = new Telphone(); class Telphone: public Telphone() { System.out.println(\"Telphone Constractor\"); } 4、带参构造方法的使用 main(): Telphone phone2 = new Telphone(5.0f); class Telphone: public Telphone(float newScreen) { screen = newScreen; } 5、当没有指定构造方法时，系统会自动添加无参的构造方法。 6、当有指定构造方法，无论是有参、无参的构造方法，系统都不会自动添加无参的构造方法。 7、构造方法的重载：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择相应的方法。 8、构造方法不但可以给对象的属性赋值，还可以保证给对象的属性赋一个合理的值 // Tp.java package com.test pubilc class Tp { private float screen; public Tp() { System.out.println(\"com.test Tp无参构造方法执行了\"); } public Tp(float newScreen) { if (newScreen Java 中的 static 使用之静态变量 Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。当然，鉴于他作用的特殊性更推荐用类名访问~~ 使用 static 可以修饰变量、方法和代码块。 [!WARNING|style:flat|label:注意] 静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收！ Java 中的 static 使用之静态方法 与静态变量一样，使用 static 修饰的方法，称为静态方法或类方法。比如之前使用的 main 方法就是静态方法。静态方法的使用如： 1、静态方法中可以直接调用同类中的 静态成员，但不能直接调用 非静态成员。 如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量 2、在普通成员方法中，则可以直接访问 同类 的非静态变量和静态变量 3、静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法 Java 中的 static 使用之静态初始化块 Java 中可以通过初始化块进行数据赋值 public class Hello { String name; // 定义一个成员变量 // 通过初始化块，为成员变量赋值 { name = \"hello\"; } } 在类的声明中，可以包含多个初始化块，当创建类的实例时，就会依次执行这些代码块。如果使用 static 修饰初始化块，就称为静态初始化块。 [!WARNING|label:注意|style:flat] 静态初始化块只在 类加载时执行，且 只会执行一次，同时静态初始化块 只能给静态变量赋值，不能初始化普通的成员变量。 结果： 通过输出结果，我们可以看到，程序运行时静态初始化块最先被执行，然后执行普通初始化块，最后才执行构造方法。由于静态初始化块只在类加载时执行一次，所以当再次创建对象 hello2 时并未执行静态初始化块。 代码 package com.test2; public class HelloWorld { int num1; int num2; static int num3; public HelloWorld () { num1 = 91; System.out.println(\"通过构造方法为变量num1赋值\"); } { num2 = 74; System.out.println(\"通过初始化块为变量num2赋值\"); } static { num3 = 3; System.out.println(\"通过静态初始化块为静态变量num3赋值\"); } public static void main (String[] args) { HelloWorld h = new HelloWorld(); System.out.println(\"num1: \" + h.num1); System.out.println(\"num2: \" + h.num2); System.out.println(\"num3: \" + HelloWorld.num3); HelloWorld h2 = new HelloWorld(); } } 结果 通过静态初始化块为静态变量num3赋值 通过初始化块为变量num2赋值 通过构造方法为变量num1赋值 num1: 91 num2: 74 num3: 3 通过初始化块为变量num2赋值 通过构造方法为变量num1赋值 原教程出处 https://www.imooc.com/learn/124 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 23:49:28 "},"pages/second-season/encapsulation.html":{"url":"pages/second-season/encapsulation.html","title":"面向对象特性：封装","keywords":"","body":"封装 面向对象特性三大特性：封装、继承、多态 概念 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和方法。 好处 只能通过规定的方法访问数据 隐藏类的实例细节，方便修改和实现 封装的实现步骤 例子 public class Hello { provite float screen; // getter public float getScreen() { return screen; } // setter public void setScreen(float newScreen) { screen = newScreen; } } java中的包 1、作用 管理Java文件 解决同名文件冲突 2、包的定义：package 包名 [!WARNING|style:flat|label:注意] 必须放在Java源程序的第一行，包名间可以使用 . 号隔开，eg: com.test.HelloWorld // 例子：音乐类-MyClassMusic // music com.test.music.MyClassMusic; // movie com.test.movie.MyClassMusic; 3、系统中的包 java.(功能).(类) 包名 说明 java.lang.(类) 包含java语言基础的类 java.util.(类) 包含java语言中各种工具类 java.io.(类) 包含输入、输出相关功能的类 4、包的使用 可以通过import关键字，在某个文件使用其它文件中的类。 import com.test.music.MyClass; [!WARNING|style:flat|label:注意] Java中，包的命名规范是全小写字母拼写 使用的时候不但可以加载某个包下面的所有文件 com.test.*; 也可以加载某个具体包下的所有文件 com.test.music.*; Java中的访问修饰符 class Telphone { private float screen = 5.0f; public float getScreen() { return screen; } publick void setScreen(float newScreen) { screen = newScreen; } // ... } 访问修饰符，可以修饰 属性 和 方法 的访问范围。 访问修饰符 本类 同包 子类 其他 private o - - - 默认 o o - - protected o o o - public o o o o Java中的this关键字 1、this关键字代表当前对象 this.属性 操作当前对象的属性 this.方法 调用当前对象的方法 2、封装对象的属性的时候，经常会使用this关键字 # Eclipse编辑器自动生成getter/setter 菜单栏 -> source -> Generate Getters and Setters ... # 指定需要生成getter或setter方法的属性 class Telphone { private float screen = 5.0f; public float getScreen() { return screen; } publick void setScreen(float screen) { this.screen = screen; } // ... } Java中的内部类 内部类（Inner Class）就是定义在另外一个类里的类。与之对应，包含内部类的类被称为外部类。 内部类的主要作用如下： 1、内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类 2、内部类的方法可以直接访问外部类的所有数据，包括私有的数据 3、内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便 内部类可分为以下几种： 成员内部类 静态内部类 方法内部类 匿名内部类 成员内部类 public class Outer { int outerNumber = 10; // 成员内部类 public class Inner { int innerNumber = 20; public void print () { System.out.println(\"Inner class's print method, and outerNumber=\" + outerNumber); } } public static void main (String[] args) { // 创建外部类对象 Outer ou = new Outer(); // 创建内部类对象 Inner in = ou.new Inner(); // 调用内部类对象方法 in.print(); } } 成员内部类的使用方法： 1、Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如 public 、 protected 、 private 等 2、Inner 类中定义的 print() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性a 3、定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即： 内部类 对象名 = 外部类对象.new 内部类( ); 4、编译上面的程序后，会发现产生了两个 .class 文件 其中，第二个是外部类的 .class 文件，第一个是内部类的 .class 文件，即成员内部类的 .class 文件总是这样： 外部类名$内部类名.class [!WARNING|style:flat|label:注意] 1、外部类不能直接使用内部类的成员和方法 可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。 [!WARNING|style:flat|label:注意] 2、如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this关键字。如： 运行结果： 访问外部类中的b：1 访问内部类中的b：2 静态内部类 静态内部类是 static 修饰的内部类，这种内部类的特点是： 1、静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问 2、如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员 3、创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类(); 结果： 访问外部类中的b:1 访问内部类中的b:2 方法内部类 方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。 [!WARNING|style:flat|label:注意] 由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 22:18:58 "},"pages/second-season/inheritance.html":{"url":"pages/second-season/inheritance.html","title":"面向对象特性：继承","keywords":"","body":"继承 继承是类与类的一种关系，是一种is a的关系。 [!TIP|style:flat] Java中的继承是单继承。 优点： 1、子类拥有父类的所有属性和方法。private修饰符的属性和方法除外。 2、复用父类的代码（代码复用）。 语法： class 子类 extends 父类 例子 // Animal.java class Animal { // 相当于JavaScript的constructor public Animal() { // ... } public name; public age; public void eat() { System.out.println(\"调用了Animal的eat方法\"); } } // Dog.java class Dog extends Animal { } // Initial.java class Initial { public static void main() { Dog dog = new Dog(); dog.name = \"DD\"; dog.age = 2; dog.eat(); } } 方法的重写 如果子类对继承父类的方法不满意，可以重写父类继承的方法，当调用方法时会优先调用子类的方法。 语法规则： 返回值类型，方法名，参数类型及个数都要与父类继承的方法相同，才叫方法的重写 继承的初始化顺序 初始化父类再初始化子类 先执行初始化对象中属性，再执行构造方法中的初始化 final 关键字 使用final关键字做标识有最终的含义 1、final可以修饰类、方法、属性和变量 2、final修饰类，则该类不允许被继承 3、final修饰方法，则该方法不允许被覆盖（重写） 4、final修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值），或在构造方法中赋值（但只能选其一）。 5、final修饰变量，则该变量的值只能赋一次值，即变为常量。 final public class Animal { // ... } super 关键字 在对象的内部使用，可以代表父类对象。 访问父类的属性 super.age 访问父类的方法 super.eat() 例子 // Dog.java public void method() { System.out.println(super.age); } super的应用 1、子类的构造的过程当中必须调用其父类的构造方法。 2、如果子类的构造方法中没有显式调用父类的构造方法，则系统默认调用父类无参的构造方法。 3、如果显式的调用构造方法，必须在子类的构造方法的第一行。 // Dog.java public class Animal { // constructor public Animal() { super(); // 必须放在第一行 // ... } } 4、如果子类构造方法中既没有显式调用父类的构造方法，而父类又没有无参的构造方法，则编译就会出错。 Object类 Object类是所有类的父类，如果一个类没有使用extends关键字明确标识继承另外一个类，那么这个类默认继承Object类。 Object类中的方法，适合所有子类。 1、toString()方法 在Object类里面定义toString()方法的时候，返回的对象的哈希code码（对象地址字符串） 可以通过重写toString()方法表示出对象的属性 # Eclipse快速重写toString 菜单栏 -> source -> Generate toString 2、equals()方法 比较的是对象的引用是否指向同一块内存地址。 一般情况下比较两个对象时，比较他的值是否一致，所以要进行重写。 # Eclipse快速生成 source -> Generate hasCode() and equals()... © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 22:23:59 "},"pages/second-season/polymorphic.html":{"url":"pages/second-season/polymorphic.html","title":"面向对象特性：多态","keywords":"","body":"多态 对象的多种形态。引用多态、方法多态。 [!TIP|style:flat] 继承是多态实现的基础 引用多态 父类的引用可以指向本类的对象。 父类的引用可以指向子类的对象。 方法多态 创建本类对象时，调用的方法为本类方法。 创建子类对象时，调用的方法为子类重写的方法或者继承的方法。 // Animal.java package com.polymorphic; public class Animal { public void eat () { System.out.println(\"Animal has eat method.\"); } } // Dog.java package com.polymorphic; public class Dog extends Animal { // overwrite public void eat () { System.out.println(\"Dogs eat meat.\"); } } // Cat.java package com.polymorphic; public class Cat extends Animal { } // Initial.java package com.polymorphic; public class Initial { public static void main(String[] args) { /* * 引用多态/方法多态 */ // 父类的引用可以指向本类的对象 Animal obj1 = new Animal(); // 父类的引用可以指向子类的对象 Animal obj2 = new Dog(); Animal obj3 = new Cat(); // methods polymorphic obj1.eat(); obj2.eat(); obj3.eat(); /* * 引用类型转换 */ Dog dog = new Dog(); Animal animal = dog; // 自动类型提升，向上类型转换 // Warning // Dog dog2 = animal; // Type mismatch: cannot convert from Animal to Dog Dog dog2 = (Dog)animal; // 向下类型转换 强制类型转换 // error // Cat cat = (Cat)animal; // 编译时Cat类型(不会报错)，运行时Dog类型(抛出异常) // instanceof if (animal instanceof Cat) { Cat cat = (Cat)animal; } else { System.out.println(\"无法进行Cat类型转换\"); } } } 多态中的引用类型转换 向上类型转换（隐式/自动类型转换），是小类型到大类型的转换。 向下类型转换（强制类型转换），是大类型到小类型。容易发送数据溢出。 instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题。 package com.polymorphic; public class Initial { public static void main(String[] args) { /* * 引用多态/方法多态 */ // 父类的引用可以指向本类的对象 Animal obj1 = new Animal(); // 父类的引用可以指向子类的对象 Animal obj2 = new Dog(); Animal obj3 = new Cat(); // methods polymorphic obj1.eat(); obj2.eat(); obj3.eat(); /* * 引用类型转换 */ Dog dog = new Dog(); Animal animal = dog; // 自动类型提升，向上类型转换 // Warning // Dog dog2 = animal; // Type mismatch: cannot convert from Animal to Dog Dog dog2 = (Dog)animal; // 向下类型转换 强制类型转换 // error // Cat cat = (Cat)animal; // 编译时Cat类型(不会报错)，运行时Dog类型(抛出异常) // instanceof if (animal instanceof Cat) { Cat cat = (Cat)animal; } else { System.out.println(\"无法进行Cat类型转换\"); } } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 22:25:12 "},"pages/second-season/abstract.html":{"url":"pages/second-season/abstract.html","title":"抽象类","keywords":"","body":"Java中的抽象类 语法：使用abstract关键字修饰，则该类为抽象类。 [!TIP|style:flat|label:应用场景] 1、在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。（父类规定子类必须包含哪些方法，但不关心子类如何实现） 2、从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。 作用： 限制规定子类必须实现某些方法，但不关心实现细节。 使用规则： 1、abstract 定义抽象类 2、abstract 定义抽象方法，只有声明，不需要实现 3、包含抽象方法的类是抽象类 4、抽象类中可以包含普通的方法，也可以没有抽象方法 5、抽象类不能直接创建，可以定义引用变量 [!WARNING|style:flat|label:注意] 抽象方法没有方法体，以分号直接结束。 public abstract void call(); public abstract void message(); 例子 // Phone.java package com.phone; public abstract class Phone { public abstract void call(); public abstract void message(); } // CellPhone.java package com.phone; public class CellPhone extends Phone { @Override public void call() { // TODO Auto-generated method stub System.out.println(\"以前的手机，是通过键盘来打电话\"); } @Override public void message() { // TODO Auto-generated method stub System.out.println(\"以前的手机，是通过键盘来发短信\"); } } // SmartPhone.java package com.phone; public class SmartPhone extends Phone { @Override public void call() { // TODO Auto-generated method stub System.out.println(\"智能手机，是通过语音来打电话\"); } @Override public void message() { // TODO Auto-generated method stub System.out.println(\"智能手机，是通过语音来发短信\"); } } // Initial.java package com.phone; public class Initial { public static void main(String[] args) { // TODO Auto-generated method stub Phone tel1 = new CellPhone(); tel1.call(); tel1.message(); Phone tel2 = new SmartPhone(); tel2.call(); tel2.message(); } } 思考题： 现有Shape图形类，用Rectangle矩形和Circle圆形子类，求图形的周长和面积 // Shape.java package com.shape; public abstract class Shape { public abstract float getPerimeter(); public abstract float getArea(); } // Circle.java package com.shape; public class Circle extends Shape { final float PI = 3.1415926f; float radius; @Override public float getPerimeter() { // TODO Auto-generated method stub return this.checkRadius() ? 2 * PI * this.radius : 0; } @Override public float getArea() { // TODO Auto-generated method stub return this.checkRadius() ? PI * this.radius * this.radius : 0; } private boolean checkRadius() { if (this.radius == 0) { System.out.println(\"未设置圆半径\"); return false; } return true; } } // Rectangle.java package com.shape; public class Rectangle extends Shape { public float width; public float height; @Override public float getPerimeter() { if (this.width == 0 || this.height == 0) { System.out.println(\"未设置矩形的长或宽\"); return 0; } // TODO Auto-generated method stub return (this.width + this.height) * 2; } @Override public float getArea() { // TODO Auto-generated method stub return this.width * this.height; } } // Initial.java package com.shape; public class Initial { public static void main(String[] args) { // TODO Auto-generated method stub Rectangle rect = new Rectangle(); rect.width = 20.0f; rect.height = 10.0f; System.out.println(\"长方形边长为：\" + rect.getPerimeter() + \"厘米\"); System.out.println(\"长方形面积为：\" + rect.getArea() + \"平方厘米\"); // circle Circle circle = new Circle(); circle.radius = 20.0f; System.out.println(\"圆周为：\" + circle.getPerimeter() + \"厘米\"); System.out.println(\"圆面积为：\" + circle.getArea() + \"平方厘米\"); } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 22:26:18 "},"pages/second-season/interface.html":{"url":"pages/second-season/interface.html","title":"接口Interface","keywords":"","body":"接口 接口可以理解为一种特殊的类，由全局常量和公共的抽象方法所组成。 [!TIP|style:flat|label:概念] 类是一种具体实现，而接口定义了某一批类所需要遵守的 规范，接口不关心这些类的内部数据，及类里方法的实现细节，它只规定这些类必须提供某些方法。 语法： [修饰符] abstract interface 接口名称 [extends 父接口1, 父接口2...] { 零到多个常量定义... 零到多个抽象方法的定义... } 关键字abstract可以省略，系统自动默认会添加abstract关键字。 接口就是用来被继承、被实现的，修饰符一般建议用public [!WARNING|style:flat|label:注意] 不能使用private和protected修饰接口 接口定义 1、常量： 接口中的属性是常量，即使定义时不添加 public static final 修饰符，系统也会自动加上。 2、方法： 接口中的方法只能是抽象方法，即使定义时不添加 public abstract 修饰符，系统也会自动加上。 使用接口 一个类可以实现一个或多个接口，实现接口使用implements关键字。Java中一个类只能继承一个父类，是不够灵活的，通过实现多个接口来做补充（弥补）。 继承父类实现的接口语法： [修饰符] class 类名 extends 父类 implements 接口1, 接口2... { // 类体部分 // 如果继承了抽象类，则必须实现继承的抽象方法 // 如果遵守了某个接口，则必须实现接口中的抽象方法 } [!WARNING|style:flat|label:注意] 如果 继承了 抽象类，则必须实现继承的类规定的抽象方法 如果 遵守了某个接口，则必须实现接口中的抽象方法 如果要继承父类，则继承父类必须在实现接口以前，即extends与 implements不能交换位置。 // new -> interface // IPlayGame.java package com.phone; public interface IPlayGame { public void playGame(); } // 系统会默认添加abstract关键字 //public abstract interface IPlayGame { // public abstract void playGame(); //} // SmartPhone.java package com.phone; public class SmartPhone extends Phone implements IPlayGame { @Override public void call() { // TODO Auto-generated method stub System.out.println(\"智能手机，是通过语音来打电话\"); } @Override public void message() { // TODO Auto-generated method stub System.out.println(\"智能手机，是通过语音来发短信\"); } @Override public void playGame() { // TODO Auto-generated method stub System.out.println(\"智能手机具有了玩游戏的功能\"); } } // Psp.java package com.phone; public class Psp implements IPlayGame { @Override public void playGame() { // TODO Auto-generated method stub System.out.println(\"PSP具有了玩游戏的功能\"); } } // Initial.java package com.phone; public class Initial { public static void main(String[] args) { // TODO Auto-generated method stub Phone tel1 = new CellPhone(); tel1.call(); tel1.message(); Phone tel2 = new SmartPhone(); tel2.call(); tel2.message(); // Interface IPlayGame ip1 = new SmartPhone(); ip1.playGame(); IPlayGame ip2 = new Psp(); ip2.playGame(); } } 匿名内部类 匿名内部类：就是没有名称的内部类。 接口在使用过程当中，还经常与匿名内部类配合使用。 多用于关注实现，而不关注实现类的名称。 语法： Interface i = new Interface() { public void method() { System.out.println(\"匿名内部类实现接口的方式\"); } } package com.phone; public class Initial { public static void main(String[] args) { // TODO Auto-generated method stub Phone tel1 = new CellPhone(); tel1.call(); tel1.message(); Phone tel2 = new SmartPhone(); tel2.call(); tel2.message(); // Interface IPlayGame ip1 = new SmartPhone(); ip1.playGame(); IPlayGame ip2 = new Psp(); ip2.playGame(); // 匿名内部类实现接口 IPlayGame ip3 = new IPlayGame() { @Override public void playGame() { // TODO Auto-generated method stub System.out.println(\"匿名内部类实现接口的方式\"); } }; ip3.playGame(); // 直接new // Android中使用较为频繁 new IPlayGame() { @Override public void playGame() { // TODO Auto-generated method stub System.out.println(\"直接使用new，实现匿名内部类接口\"); } }.playGame(); } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 22:32:26 "},"pages/second-season/UML.html":{"url":"pages/second-season/UML.html","title":"UML(Unified Modeling Language)","keywords":"","body":"UML Unified Modeling Language（UML），统一建模语言或标准建模语言。 是一个支持模型化和软件系统开发的图形化语言。 为软件开发的所以阶段提供模型化和可视化支持。 UML图示 UML 2.2一共定义了14中图示（diagrams）。 常用UML图 用例图（The Use Case Diagram） [!TIP|style:flat|label:The Use Case Diagram] 用例图能够以可视化的方式，表达系统如何满足所收集的业务规则，以及特定的用户需求等信息。 序列图（The Sequence Diagram） [!TIP|style:flat|label:The Sequence Diagram] 序列图用于安装交互发生的一系列顺序，显示对象之间的这些交互。 类图（The Class Diagram） [!TIP|style:flat|label:The Class Diagram] UML类图、业务逻辑和所有支持结构一同被用于定义全部的代码结构。 UML建模工具 Microsoft Office Visio、Rational Rose、PowerDesign三种建模工具应用最广。 参考资料： https://www.cnblogs.com/Ph-one/p/7650624.html https://www.eclipse.org/modeling/mdt/downloads/?project=uml2 https://www.cnblogs.com/silent2012/archive/2011/09/07/2169946.html UML学习入门就这一篇文章 转自：http://www.uml.org.cn/oobject/201309023.asp 1.1 UML基础知识扫盲 UML这三个字母的全称是Unified Modeling Language，直接翻译就是统一建模语言，简单地说就是一种有特殊用途的语言。 你可能会问：这明明是一种图形，为什么说是语言呢?伟大的汉字还不是从图形(象形文字)开始的吗?语言是包括文字和图形的!其实有很多内容文字是无法表达的，你见过建筑设计图纸吗?里面还不是很多图形，光用文字能表达清楚建筑设计吗?在建筑界，有一套标准来描述设计，同样道理，在软件开发界，我们也需要一套标准来帮助我们做好软件开发的工作。UML就是其中的一种标准，注意这可不是唯一标准，只是UML是大家比较推崇的一种标准而已，说不定以后有一个更好的标准可能会取代她呢!UML并不是强制性标准，没有法律规定你在软件开发中一定要用UML，不能用其它的，我们的目标是善用包括UML在内的各种标准，来提高我们软件开发的水平。 UML由1.0版发展到1.1、1.2、...，到现在的2.0、2.x，本书将会以2.x版本为基础开展讨论。网络上、书籍、还有各种UML工具软件，各自基于的UML版本可能会不一样，大家在学习过程中可能会有一些困惑，不过没关系，本课程在某些关键地方会描述1.x与2.x的差异。 UML有什么用? 有很多人认为，UML的主要用途就是软件设计!也有人认为，如果你不是开发人员，是难以理解UML的。 然而我第一次在实际工作中应用UML的却不是软件设计，而是软件需求分析!当时我们和客户面对面沟通调研需求的时候，直接用类图、顺序图、活动图、用例图等UML。我们并没有因此和客户无法沟通，反而是沟通得更加顺畅。客户在我们的引导下，很快就会读懂这些UML图，因为UML图，让我们和客户的沟通效率和效果更好!你可能觉得很神奇，在后续章节中，我将会为你逐一揭开神奇背后的“秘密”。 UML可帮助我们做软件需求分析和软件设计的工作，在我工作中大概各占了50%的比例，当然在你的实际工作中不一定是这样的比例。UML会让你的需求分析或者软件设计工作更上一层楼，本书将会介绍UML在需求分析方面的最佳实践。 告诉你一个秘密，UML应用于软件需求分析时，其学习门槛将会大大降低!语法复杂度会降低，而且你基本不需要掌握软件开发的知识。只要你对软件需求分析感兴趣，认真学习和应用UML，就很有机会成为软件需求分析高手。 UML的分类 结构型的图(Structure Diagram) 类图(Class Diagram) 对象图(Object Diagram) 构件图(Component Diagram) 部署图(Deployment Diagram) 包图(Package Diagram) 行为型的图(Behavior Diagram) 活动图(Activity Diagram) 状态机图(State Machine Diagram) 顺序图(Sequence Diagram) 通信图(Communication Diagram) 用例图(Use Case Diagram) 时序图(Timing Diagram) 本书所描述的UML的各种图的名字，以上述的为准。 UML各种图的中文译名，因为翻译的原因可能会有所不一样，如：Sequence Diagram和Timing Diagram有时候都会被译成“时序图”，这是最让人困扰的地方!Sequence Diagram 除了被译为顺序图，还有序列图的译法。 中国软件行业协会(CSIA)与日本UML建模推进协会(UMTP)共同在中国推动的UML专家认证，两个协会共同颁发认证证书、两国互认，CSIA与UMTP共同推出了UML中文术语标准，该标准全称为：CSIA-UMTP UML中文术语标准v1.0(本书后文将会简称为UML中文术语标准)。本书将会遵循UML中文术语标准，并且我们会同时给出中文译名和英文原名，大家要留意看英文名字噢，这样能帮助你不会被众多的中文译名混淆。 UML图为什么会分为结构型和行为型两种呢? 顾名思义，结构型的图描述的是某种结构，这种结构在某段时间内应该是稳定的，“静态”的;而结构型的图描述的是某种行为，是“动态”的。 分析系统需求时，我们会面对很多业务概念，它们之间会有某些关系，这些内容可以看成是“静态”的，我们可以利用UML的结构性的图来分析。同时，业务会涉及大量的流程、过程等，这些内容是“动态”的，我们可以用行为型的UML图来分析。 在我们软件设计时，我们需要考虑需要那些类、哪些构件、系统最后怎样部署等，这些内容可以看成是“静态”的，我们可以利用UML的结构型的图来设计。同时，我们也需要考虑软件如何和用户交互，类、构件、模块之间如何联系等“动态”内容，我们可以利用行为型的图来设计。 所谓“静态”和“动态”不是绝对的，下文我们将会进一步介绍结构型的UML和行为型的UML。通过下面的学习，你将会初步认识UML的各种图，你可能还会有很多问题，本章的主要目的是让你对UML有一个宏观的认识，带着你的问题继续阅读后面的章节吧! 1.2 结构型的UML(Structure Diagram) 类图(Class Diagram) 某模具系统类图 此图截取自某模具管理系统的业务概念分析图，图中一个一个的矩形就是类，这些类之间有各种线条连接，这些线条表示类之间的关系。类图是分析业务概念的首选，类图可能是使用率最高的UML图。 再看下面这个Person类图，这时软件设计时用到的一个图： Person类图 该Person类有以下属性(Attribute)：Name(姓名),Sex(性别),Department(部门)等，有以下操作(Operation)：Work(工作)等。类有属性和操作，但用类图分析业务模型时，往往不需要使用操作，如图1.1中的类就只有属性。 Attribute有特性、特征等译法，Operation也称作方法，但本书遵循UML中文术语标准，即Attribute为属性，Operation为操作。 对象图(Object Diagram) 一般情况下只有在软件开发中才会使用到对象图，下面的内容以开发的角度来说明对象图，如果你没有开发经验，阅读起来可能有一点难度。 图1.2中的Person类，用代码实例化如下： Person person = new Person(); …… 类(Class)实例化后就是对象(Object)，对象person是类Person的实例，上述代码可以用对象图表示如下： Person类的对象图 对象图和类图的样子很相似，对象是类的实例化，“person : Person”表示对象person是类Person的实例。对象图往往只在需要描述复杂算法时才会使用，画出来的对象图往往不会只有一个对象，该图只画了一个对象，其目的是尽量简化以便读者的理解什么是对象图。 在需求分析工作中基本上不需要使用对象图，从严谨的角度来看某些情况下应该使用对象图，但我往往还是会用类图来处理，这样更加简便而且容易理解。我们将在类图一章再次讲解对象图。 构件图(Component Diagram) 构件图也叫组件图，两个名字均符合UML中文术语标准。 一辆汽车由轮子、发动机等物理部件组成，一个软件往往也是由很多“物理部件”(如：控件、重用构件等)组成的，构件图就是用来描述软件内部物理组成的一种图。下图是某权限构件设计图： 图1.4某权限构件设计图 图1.4右上方有这样标志 的矩形表示一个构件，构件可以再包含构件。 软件需求分析工作中，需要用到构件图的情况不是很多，以下情况除外： 1、待开发的系统需要与第三方的系统、原有系统、某些老系统等交互，这时可用构件图描述交互要求。 2、客户对软件设计有某些特殊要求，这时可用构件图来描述要求。 构件图有时不会单独使用，还会和部署图一起结合使用。 部署图(Deployment Diagram) 部署图是用来描述系统如何部署、本系统与其他系统是怎样的关系的一种图，如下图： 图 1.5 某24小时便利店的管理系统部署图 图中一个个立体的矩形是部署图的“节点”，一个节点表示一个物理的设备，节点之间的线条表示节点间的物理连接关系。 大部分客户都会具备一定的IT基础环境(如具备局域网、一些服务器、某些软件平台等)，软件系统需要基于当前的IT基础环境来规划，这时我们可以使用部署图来做这个规划。 分析系统的需求，不能忽略系统架构、部署、IT架构等方面的要求，我们要基于客户当前的IT基础环境，做一个最符合客户利益的规划。 要活用构件图、部署图来分析需求，需要具备一定的IT基础架构知识和软件设计知识，如果你还不具备相关知识，那么可以考虑抓紧补充相关知识。不过需求分析工作更多的还是分析业务，提炼功能性需求，这部分工作能做好是相当不容易的事情。对于技术方面的非功能性需求分析，可交由有技术背景的专业人士负责。 包图(Package Diagram) Package有“打包”的意思，包图的主要用途是“打包”类图。用类图描述业务概念时，很多时候会因为业务类太多，而导致类图非常庞大，不利于阅读，这时可以将某些类放入“包”中，通过包图来组织业务概念图。 下图是包图的一个示例： 包图 图中好像文件夹样子的就是一个“包”，包之间的线条表示包之间的关系。 1.3 行为型的UML(Behavior Diagram) 活动图、状态机图、顺序图处于三种不同的角度来描述流程，是分析业务流程的三种不同利器，下面将会逐一说明。 活动图(Activity Diagram) 我们将起床到出门上班这个过程画成活动图，可能是这样的： 图 1.7 起床到出门上班的活动图 活动图中的一个圆边框框表示一个“活动”，多个活动之间的带箭头线条表示活动的先后顺序，该图只是表达了一个顺序流程，活动图还可以表达分支结构。如果你以前曾学过流程图的话，你会发现活动图和流程图很相似。活动图可能是三种能表示流程的UML图中最接近我们思维习惯的一种，下面来学习另外两种能表达流程的图。 状态机图(State Machine Diagram) 状态机图又叫状态图，但状态图这个译名并没有译出Machine的意思。 状态机图从某个物品的状态是如何变化的角度来展示流程，下图某请假条审批流程： 图 1.8 请假处理流程 整个请假审批流程是围绕“请假条”这个物体进行的，随着不同的审批阶段，请假条具备不同的状态。我们分析业务流程时会发现很多流程其实是围绕某个物品进行的，这时可考虑使用状态机图。 顺序图(Sequence Diagram) 你去餐厅吃饭，向服务员点餐到服务员送菜上来，这个过程用顺序图可表示如下： 图 1.9 点菜的顺序图 该图有三个“小人”，每个“小人”下面的文字说明(如：顾客)表示其代表的角色。角色与角色之间有一些线条链接，表示角色之间是如何交互的。该图表示的意思是：顾客向服务员点菜后，服务员将点菜信息传递给厨师，然后厨师做菜，最后再由服务员送菜给你。 点菜过程涉及几个环节，每个环节均由不同的角色来负责，如果遇到类似的情况，你可以考虑使用顺序图来分析。用顺序图来分析的好处是能清晰表达整个过程所参与的角色，角色与角色之间的关系，各角色是如何被卷入这个过程当中的。 通信图(Communication Diagram) UML1.1时，该图英文名为Collaboration Diagram;UML2.x时，英文名为Communication Diagram。将英文名字直接翻译，原来的英文名字可译为协作图，而新的英文名字译为通信图。 通信图是顺序图的另外一种画法，点菜的顺序图，如果用通信图来画可表示如下： 图 1.10 点菜的通信图 三个“小人”分表表示三种角色：顾客、服务员、厨师;角色之间有直线联系表示他们之间有关系;带序号的文字和箭头，表示角色之间传递的信息。 顺序图更强调先后顺序，通信图更强调相互之间的关系。我觉得顺序图实用性更好一点，比通信图能表达更多的信息，更容易读懂，在需求分析工作中我基本不会使用通信图。 用例图(Use Case Diagram) 下图是用例图的示意图： 图 1.11 用例图 用例图表达的是什么角色通过软件系统能做什么事情，我们可以使用用例图系统地表达软件系统的绝大部分需求。 时序图(Timing Diagram) 时序图也叫时间图，时序图是UML中文术语标准的说法，而时间图不是标准的说法。 时序图是表示某东西的状态随时间变化而变化的一种图，参见下图： 图 1.12 灯的开关状态随时间变化图 此图表示在0秒到30秒，灯的状态是关的，30-60秒灯的状态为开，60秒后状态为关。 在实际工作中我基本上没有试用过时间图。 下面通过这个表格来总结一下我在需求分析工作中应用各种UML图的情况： 表 1.1 各种UML图实际应用情况 上表是根据我的工作经验总结的，相信会适用于很多情况。但每个人的工作经历、情况、环境等不太一样，上表仅作参考。 1.4 如何学好UML? UML的认识误区 误区一：认为UML主要用于软件设计。 前面的文章你可以看到，UML除了用于软件设计，还能用于需求分析，而本书就是专门来说明如何在需求分析工作中活用UML的。 误区二：客户无法理解UML，在需求分析中应用UML实际意义不大。 我还不熟悉UML时，确实也有这样的怀疑，而实际工作中发现UML恰恰成为与客户沟通的良好桥梁!UML其实不难读懂，只要稍加解释客户马上就能读懂。我在所有的项目需求分析工作中，都直接使用UML图与客户沟通，并且给客户签署的需求规格说明书中含有大量的UML图。 UML能直观、形象、严谨地描述出业务概念、业务流程、客户的期望和需求，只要稍加引导客户，客户将会很容易读懂UML，甚至会主动使用UML与项目组交流。我曾经遇到过客户向我们索要画UML图的工具，客户见识过UML的威力后，也想在自己实际工作中使用。 误区三：认为UML语法繁杂，难以学习和应用。 某些UML资料和书籍可能将UML说得过于复杂了，官方的UML标准资料也确实是枯燥难懂、人见人晕。我刚开始学习UML时，也看过一些UML书籍，觉得UML的语法太多、太复杂、太容易混淆了! 在实际工作中，其实经常需要用到的UML语法并不多，而且很容易掌握。当我们在需求分析方面应用UML时，需要掌握的语法更少(在软件设计方面应用UML时需要掌握稍多一点的语法)。“二八原则”在这里完全适用，我们经常用到的UML语法，其实只占全部语法的20%，而本书将会重点介绍实用性强的UML语法。 误区四：UML用途不大。 很多人推崇UML，但也有不少人士不太认可UML。不认可的原因主要是因为一些人士学习UML后，发现在实际工作中发挥的作用并不是很大，有时候不用UML效果更好。 我不敢说UML能帮助我们解决所有问题，至少从我的多年使用经验上来说，UML对于提升我的需求分析能力帮助还是很大的。有人之所以感觉UML不太好用，我觉得原因还是只掌握了UML的形而没有领会UML的神。UML的常用语法可能几天就能学会了，而要真正做到“thinking in UML”却没有这么容易，需要长期的锻炼。 我的学习经历 我读大学时没有听说过UML，出来工作两三年后才开始接触UML，当时的感觉就好像找到了新大陆，很想好好发掘一番!而我当时的运气还是相当不错的，我的上司是UML达人，他带领我参加了项目的需求分析工作。我很快就见识了UML威力，在他的言传身教之下，迅速掌握了UML。 在那个项目以后，我便独立担当了多个项目管理及需求分析工作，没有一个项目不应用UML，而且我毫不保留地传授UML知识给项目组的其他成员。多年的工作进一步磨练了自己，对UML在实际工作中的应用有了更深刻的认识，形成自己的一套方法。 我的UML知识绝大部分来自于工作实践，期间虽然也看过一些书籍，但对我的帮助很少。当然我最大的得益还是来自我的UML启蒙老师，他在实际工作中教会了我UML，帮助我踏上自我成长的道路。 我的UML学习最大体会就是：实践太重要了!如果有名师指导则会让你事半功倍!希望本书能成为你在实际工作中学习和应用UML的好帮手! UML学习难点 学UML之难，不在于学习语法，关键是要改变思维习惯。UML是一种新的工具，但同时也是代表了一种新的先进的思考方法，如果不能掌握这样的方法，只能学到了UML的形，而没有掌握其神髓。 要用好UML，你需要在平时多多培养下面的能力： 1、书面表达能力。 2、归纳总结能力。 3、“面向对象”的思维能力和抽象能力。 平时你可以利用各种机会来提升第1和第2种能力，如多写写项目文档、写写日记或博客等，多思考和总结平时自己的工作得失等。 第3种能力说起来有点虚，大家在大学中可能也学过相关知识。训练这种能力的最好方法就是多应用类图，我们将会在类图的章节再重点介绍，通过实例来体会什么才叫“面向对象”! 本书将会重点培养你的这三种能力，只要你有进步之心，多练习、多实践、多思考、多总结，一定会取得长足进步! 1.5 小结 本章的主要目标是让你不需要阅读全书的情况下，就可以了解到UML的全貌，大概知道UML各种图的用途，同时给你说明学习UML的难点，为最终活用UML做好准备。下面我们一起来复习一下本章的主要内容： UML是Unified Modeling Language的简称，是软件开发界的一套标准，UML不仅可用于软件设计，也可以用于软件需求分析。但UML并不是强制标准，我们应该善用包括UML在内的各种标准来提高我们的水平。 UML可分为两类：结构型、行为型，结构性的UML有：类图、对象图、构件图、部署图、包图，行为型的图有活动图、状态机图、顺序图、通信图、用例图、时间图。 类图是业务概念模型分析的有利武器，也是面向对象分析能力的强有力训练工具。 对象图在需求分析工作中并不常用。 构件图、部署图是分析IT基础架构、软件架构等方面需求的有利分析工具，但需要你具备IT基础架构、软件设计方面的知识和经验。 包图可用来组织类图，在需求分析工作中应用的机会不是很大。 活动图、状态机图、顺序图是分析业务流程的强力武器。活动图的表达思路与流程图很类似，很容易掌握，而且大部分情况下都可以使用活动图来分析业务流程;某流程如果是围绕某个物品进行，该物品在流程中转换多种状态，那么使用状态机图来分析是首选;用顺序图来分析的好处是能清晰表达整个过程所参与的角色，角色与角色之间的关系，各角色是如何被卷入这个过程当中的。 通信图可以看作是顺序图的另外一种表达形式，顺序图更强调先后顺序，通信图更强调相互之间的关系。而从我的工作经验看，顺序图更加实用一点。 有人会将用例图称作“公仔图”，用例图表达的是什么角色通过软件系统能做什么事情，我们可以使用用例图系统地表达软件系统的绝大部分需求。 时间图是表示某东西的状态随时间变化而变化的一种图，我在实际工作中很少有机会能用到这种图。 学UML之难，不在于学习语法，避免陷入UML的认识误区，多练习、多实践，培养良好的“think in UML”思想，锻炼面向对象分析的能力，成为活用UML的需求分析高手不远矣! © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 22:57:38 "},"pages/third-season/exception.html":{"url":"pages/third-season/exception.html","title":"异常与异常处理","keywords":"","body":"异常与异常处理 字面意思：有异于常态，和正常情况不一样，有错误出现。 程序中：阻止当前方法或作用域正常运行的情况，称之为异常。 [!TIP|style:flat|label:Exception异常] 异常指的是在程序运行过程中发生的异常事件，通常是由外部问题（如硬件错误、输入错误）所导致的。在Java等面向对象的编程语言中异常属于对象。 导致的问题： 1、程序得不到正常的运行，不能正常退出 2、导致用户数据丢失 3、程序运行的资源得不到有效的释放 异常处理作用： 1、对异常正确的处理，能将异常提示给编程人员或者是用户 2、使已中断的程序，以适当的方式继续运行或退出，并且可以保存用户的当前操作，或数据回滚 3、最后再把占用的资源释放掉 Throwable类 主要有两个儿子Error与Exception，即Error与Exception类继承Throwable类 Error 错误 [!TIP|style:flat|label:Error] 系统错误，内存溢出 虚拟机错误 VirtualMachineError 线程死锁 ThreadDeath 它的出现，即意味着程序挂了，即程序终结者 好比工厂停水/停电/机器挂了 Exception 异常 [!TIP|style:flat|label:Exception] 编码、环境、用户操作输入出现问题 主要有 RuntimeException 称之为非检查异常 其他异常称之为：检查异常 CheckException 非检查异常 RuntimeException 引起RuntimeException的原因： 1、引用了一个空对象或方法。空指针异常 NullPointerException String str = null; System.out.println(str.length()); 2、数组访问越界。数组下标越界异常 ArrayIndexOutOfBoundsException int[] arr = { 1, 2, 3 } for (int i = 0; i 3、错误的类型转换。类型转换异常 ClassCastException class Animal {} class Dog extends Animal {} class Cat extends Animal {} public class Test { public static void main (String[] args) { Animal a1 = new Dog(); Animal a2 = new Cat(); Dog d1 = (Dog)a1; Dog d2 = (Dog)a2; } } 4、运算异常，整数去整除零。算术异常 ArithmeticException int a = 12; int b = 0; System.out.println(a / b); 5、等等... [!TIP|style:flat|label:RuntimeException] 运行时异常 会由Java虚拟机自动抛出，并自动捕获。 运行时异常的出现，多数情况下说明代码本身出了问题，应该从逻辑上去改进代码。 检查异常 CheckException 比如：文件异常 IOException，SQl异常 SQLException等等很多，需要开发人员自己捕获及处理。 异常处理 try-catch, try-catch-finally 语法 try { // 一些会抛出异常的方法 } catch (Exception e) { // 处理该异常的代码块 } [!WARNING|style:flat|label:如果try抛出异常将会发生什么？] 抛出异常的方法会终止执行！ 程序的控制权将被移交给catch块中的异常处理程序 catch中可以做的事情： 根据业务情况，可以发出一些警告，提示用户或开发人员 也可以记录错误日志等操作等等 try { System.out.print(\"请输入你的年龄：\"); Scanner input = new Scanner(System.in); int age = input.nextInt(); System.out.println(\"The ten years ago, you will\" + (age + 10)); } catch (InputMismatchException e) { System.out.println(\"你应该输入整数！\"); } System.out.println(\"程序结束啦！\"); try会抛出很多种类型的异常，该如何处理？ Scanner input = new Scanner(System.in); try { System.out.print(\"请输入第一个数：\"); int one = input.nextInt(); // input 12 System.out.print(\"请输入第二个数：\"); int tow = input.nextInt(); // input 0 System.out.println(one / tow); } catch (InputMismatchException e) { // 输入不匹配异常 System.out.println(\"你应该输入整数！\"); } catch (ArithmeticException e) { // 英 [əˈrɪθmətɪk] 美 [əˈrɪθmɪtɪk] // 算术异常 System.out.println(\"除数不能为0！\"); } catch (Exception e) { System.out.println(\"不知名异常！\"); } finally { // 最终将要执行的一些代码 } System.out.println(\"程序结束啦！\"); 异常处理注意事项 异常捕获顺序，一定要按先小后大，即先子类再父类： 子类 -> 父类 当异常发生时，异常处理系统会就近寻找匹配的异常处理的catch程序。子类继承于父类，针对于子类的处理程序，父类也是适用的。 善后工作处理 finally 异常发生后，可以使用finally关闭连接，或关闭文件等善后操作。 例子 package com.trycatch.test; public class TryCatchTest { public static void main(String[] args) { // TODO Auto-generated method stub TryCatchTest tc = new TryCatchTest(); int result = tc.test(); System.out.println(\"result: \" + result); } /** * test method * @return */ public int test() { int divider = 10; int result = 0; try { while (divider > -1) { divider--; result += 100 / divider; } return result; } catch (Exception e) { // 打印异常 e.printStackTrace(); System.out.println(\"程序抛出异常了！！\"); return -1; } } } 结果 java.lang.ArithmeticException: / by zero at com.trycatch.test.TryCatchTest.test(TryCatchTest.java:22) at com.trycatch.test.TryCatchTest.main(TryCatchTest.java:8) 程序抛出异常了！！ result: -1 test2 package com.trycatch.test; public class TryCatchTest { public static void main(String[] args) { TryCatchTest tc = new TryCatchTest(); int result2 = tc.test2(); System.out.println(\"test2返回值result为: \" + result2); } /** * test method * @return */ public int test2() { int divider = 10; int result = 0; try { while (divider > -1) { divider--; result += 100 / divider; } return result; } catch (Exception e) { // 打印异常 e.printStackTrace(); System.out.println(\"Test2抛出异常了！！\"); return 999; } finally { System.out.println(\"这是finally！\"); System.out.println(\"Result值为：\" + result); } } } 结果 java.lang.ArithmeticException: / by zero at com.trycatch.test.TryCatchTest.test2(TryCatchTest.java:45) at com.trycatch.test.TryCatchTest.main(TryCatchTest.java:10) Test2抛出异常了！！ 这是finally！ Result值为：281 test2返回值result为: 999 [!TIP|style:flat|label:总结] catch块跟在try语句后面，它可以是一个或多个 catch块有一个参数，该参数是某种异常类的对象 多重catch语句中，异常类型必须子类在前，父类在后 原视频教程出处 https://www.imooc.com/learn/110 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-04 23:22:44 "},"pages/third-season/throw.html":{"url":"pages/third-season/throw.html","title":"异常抛出及自定义异常","keywords":"","body":"异常抛出及自定义异常 Java中的异常抛出 throw 将产生的异常抛出（动作） throws 声明将要抛出何种类型的异常（声明） public void 方法名(参数列表) throws 异常列表 { // 调用会抛出异常的方法或者： throw new Exception(); } 例子：声明抛出一个异常 public void divide(int one, int two) trhows Exception { if (two == 0) { throw new Exception(\"两数相除，除数不能为0\"); } else { System.out.println(\"两数相除，结果为：\" + one / two); } } 处理1：使用try-catch处理 public void compute () { // do something try { divide(5, 0); } catch (Exception e) { System.out.println(e.getMessage()); } } 处理2：(或)继续抛出异常，让其他更上一层调用程序去处理 public void compute() throws Exception { // do something divide(5, 0); } 自定义异常 class 自定义异常类 extends 异常类型 { // do something } 例子 package com.test public class DrunkException extends Exception { // 自定义一个有参的构造器 public DrunkException(String message) { super(message); } // 因为自定义了构造器，所以编译器不会为我们自动创建一个无参构造器 // 但，有时候我们需要用到无参的构造器，所以再添加一个无参构造器 public DrunkException() { // ... } } Java中的异常链 异常链功能实现，两种实现方法： package com.test public class ChainTest { /** * test1()：抛出\"喝大了\"异常 * test2()：调用test1()，捕获\"喝大了\"异常，并且包装成运行时异常，继续抛出 * main方法中，调用test2()，尝试捕获test2()方法抛出的异常 */ public static void main(String[] args) { ChainTest ct = new ChainTest(); try { ct.test2(); } catch (Exception e) { e.printStack(); } } public void test1 () throws DrunkException { throw new DrunkException(\"喝酒别开车！\"); } public void test2 () { try { test1(); } catch (DrunkException e) { // 包装成运行时异常 RuntimeException newExc = new RuntimeException(\"司机一滴酒，亲人两行泪\"); newExc.initCause(e); throw newExc; } } } 或者 public void test2 () { try { test1(); } catch (DrunkException e) { // 包装成运行时异常 RuntimeException newExc = new RuntimeException(e); throw newExc; } } [!TIP|style:flat|label:总结] Exception的父类是Throwable 使用try-catch-finally语句捕获并处理异常 可以使用throw语句抛出异常 实际应用中的经验与总结 1、处理运行时异常时，采用逻辑去和里规避同时辅助try-catch处理 2、在多重catch块后面，可以加一个catch（Exception）来处理可能会被遗漏的异常 3、对于不确定的代码，也可以加上try-catch，处理潜在的异常 4、尽量去处理异常，切忌只是简单的调用printStackTrace()去打印输出 5、具体如何处理异常，要根据不同的业务需求和异常类型去决定 6、尽量添加finally语句块去释放占用的资源，尤其是在有网络连接或有数据库操作的情况下等等。 练习题 要求： 1、定义字符串数组保存图书信息 2、提示用户输入，分别按\"书名\"和\"图书序号\"查找图书 3、根据输入信息进行适当的异常处理 a、如果输入类型错误，抛出\"错误命令异常\"，并提示重新输入 b、如果书名不存在，抛出\"图书不存在异常\"，并提示重新输入 c、如果图书序号超过字符串数组范围，抛出\"图书不存在异常\"，并提示重新输入 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-07 08:51:45 "},"pages/third-season/string.html":{"url":"pages/third-season/string.html","title":"字符串","keywords":"","body":"字符串 在 Java 中，字符串被作为 String 类型的对象处理。 String 类位于 java.lang 包中。默认情况下，该包被自动导入所有的程序。 创建String对象的方法 创建一个字符串对象\"Hello World\"，变量名为str String str = \"Hello World\"; 创建一个空字符串对象 String str = new String(); 创建一个字符串对象 String str = new String(\"Hello World\"); 字符串的不变性 String 对象创建后则 不能被修改，是不可变的。所谓的修改其实是创建了新的对象，所指向的内存空间不同。 String str1 = \"Hello World\"; String str2 = \"Hello World\"; String Str3 = new String(\"Hello World\"); String Str4 = new String(\"Hello World\"); // 多次出现的字符串常量，Java编译程序只创建一个，所以返回true System.out.println(str1 == str2); // str1和str3是不同的对象，所以返回false System.out.println(str1 == str3); // str3和str4是不同的对象，所以返回false System.out.println(str3 == str4); str1 = \"Wolcome to \" + str1; // 字符串str1被修改，指向新的内存空间 System.out.println(str1); [!TIP|style:flat|label:总结] 在第一次使用字符串引用的使用，也是通过new来创建字符串的，只是隐式的new一个字符串对象 在你第二次使用同一个字符串的时候，会查找堆内存中有没有和该字符串一样的，如果有就直接引用这个堆中已经有的字符串对象，如果没有，还是会new一个； 而直接使用new的方法，创建字符串，是不管堆中有没有，直接创建一个新的对象，所以在比较的时候，都是false 关系图说明： 1、通过 String str1 = \"Hello World\"; 声明了一个字符串对象， str1 存放了到字符串对象的引用。 然后通过 str1 = \"Wolcome to \" + str1; 改变了字符串 str1 ，其实质是创建了新的字符串对象，变量 str1 指向了新创建的字符串对象。 2、一旦一个字符串在内存中创建，则这个字符串将不可改变。如果需要一个可以改变的字符串，我们可以使用StringBuffer或者StringBuilder。 3、每次 new 一个字符串就是产生一个新的对象，即便两个字符串的内容相同，使用 == 比较时也为 false ,如果只需比较内容是否相同，应使用 equals() 方法。 String 类的常用方法 package com.string; import java.util.Arrays; public class StrTest { public static void main(String[] args) { String str = \"Hello World\"; System.out.println(\"length(): \" + str.length()); // find char W char w = 'W'; System.out.println(\"indexOf('W'): \" + str.indexOf(w)); // split array String[] arr = str.split(\" \"); System.out.print(\"Arrays.toString(): \" + Arrays.toString(arr)); System.out.println(); // get children string by index[3, 7) System.out.println(\"get the substring of index[3, 7), with substring(): \" + str.substring(3, 7)); // System.out.println(\"toLowerCase(): \" + str.toLowerCase()); System.out.println(\"toUpperCase(): \" + str.toUpperCase()); System.out.println(\"charAt(1): \" + str.charAt(1)); // to byte[] byte[] b = str.getBytes(); System.out.print(\"to bytes: \"); for (int i = 0; i 运行结果： length(): 11 indexOf('W'): 6 Arrays.toString(): [Hello, World] get the substring of index[3, 7), with substring(): lo W toLowerCase(): hello world toUpperCase(): HELLO WORLD charAt(1): e to bytes: 72 101 108 108 111 32 87 111 114 108 100 Are str and str2 memory addresses the same? false Is Str the same as str2? true [!TIP|style:flat|label:总结] 1、字符串 str 中字符的索引从0开始，范围为 0 到 str.length()-1 2、使用 indexOf 进行字符或字符串查找时，如果匹配返回位置索引；如果没有匹配结果，返回 -1 3、使用 substring(beginIndex , endIndex) 进行字符串截取时，包括 beginIndex 位置的字符，不包括 endIndex 位置的字符 “==” 和 equals() 有什么区别呢？ == : 判断两个字符串在内存中首地址是否相同，即判断是否是同一个字符串对象 equals() : 比较存储在两个字符串对象中的内容是否一致 package com.string; public class CNStrTest { public static void main(String[] args) { String str = \"String类常用方法。\"; try { byte[] b = str.getBytes(\"GBK\"); for (int i = 0; i 运行结果： 83 116 114 105 110 103 -64 -32 -77 -93 -45 -61 -73 -67 -73 -88 -95 -93 [!TIP|style:flat|label:PS] 字节是计算机存储信息的基本单位，1 个字节等于 8 位， gbk 编码中 1 个汉字字符存储需要 2 个字节，1 个英文字符存储需要 1 个字节。 所以我们看到上面的程序运行结果中，每个汉字对应两个字节值，如“类”对应 “-64 -32 ” ，而英文字母 “S” 对应 “83” 。 同时，我们还发现汉字对应的字节值为负数，原因在于每个字节是 8 位，最大值不能超过 127，而汉字转换为字节后超过 127，如果超过就会溢出，以负数的形式显示。 在java中，一个英文字符占多少字节，一个中文字符占多少字节？ by 慕课网友：Yesabella [!WARNING|style:flat|label:字节补充] Java采用unicode来表示字符，java中的一个char是2个字节，一个中文或英文字符的unicode编码都占2个字节，但如果采用其他编码方式，一个字符占用的字节数则各不相同。 在 GB 2312 编码或 GBK 编码中，一个英文字母字符存储需要1个字节，一个汉子字符存储需要2个字节。 在UTF-8编码中，一个英文字母字符存储需要1个字节，一个汉字字符储存需要3到4个字节。 在UTF-16编码中，一个英文字母字符存储需要2个字节，一个汉字字符储存需要3到4个字节（Unicode扩展区的一些汉字存储需要4个字节）。 在UTF-32编码中，世界上任何字符的存储都需要4个字节。 如果编码方式为GBK，对于字符串“测试test”，字符长度为6，字节长度为8。 如果编码方式为UTF_8，对于字符串“测试test”，字符长度为6，字节长度为10。 String aa = \"学\"; System.out.println(\"UTF-8编码长度:\"+aa.getBytes(\"UTF-8\").length); System.out.println(\"GBK编码长度:\"+aa.getBytes(\"GBK\").length); System.out.println(\"GB2312编码长度:\"+aa.getBytes(\"GB2312\").length); // 运行结果 // UTF-8编码长度:3 // GBK编码长度:2 // GB2312编码长度:2 练习 public class HelloWorld { public static void main(String[] args) { // 定义一个字符串 String s = \"aljlkdsflkjsadjfklhasdkjlflkajdflwoiudsafhaasdasd\"; // 出现次数 int num = 0; // 循环遍历每个字符，判断是否是字符 a ，如果是，累加次数 for ( int i = 0; i StringBuilder 类 在Java中，除了可以使用 String 类来存储字符串，还可以使用 StringBuilder 类或 StringBuffer 类存储字符串，那么它们之间有什么区别呢？ String str = \"Hello\"; System.out.println(str + \" World\"); System.out.println(str); 结果 Hello World Hello 从运行结果中我们可以看到，程序运行时会额外创建一个对象，保存 \"Hello World\"。当频繁操作字符串时，就会额外产生很多临时变量。 使用 StringBuilder 或 StringBuffer 就可以避免这个问题。 [!TIP|style:flat|label:StringBuilder和StringBuffer] 它们基本相似，不同之处，StringBuffer 是 线程安全的，而 StringBuilder 则没有实现线程安全功能，所以性能略高。 因此一般情况下，如果需要创建一个内容可变的字符串对象，应优先考虑使用 StringBuilder 类。 定义 // 创建一个StringBuilder对象 StringBuilder str1 = new StringBuilder(); // 创建一个字符串\"Hello World\" StringBuilder str2 = new StringBuilder(\"Hello World\"); System.out.println(str2); 常用方法 方法 说明 StringBuilder append(参数) 追加内容到当前StringBuilder对象的末尾 StringBuilder insert(位置, 参数) 将内容插入到StringBuilder对象的指定位置 String toString() 将StringBuilder对象转换为String对象 int length() 获取字符串的长度 练习：将一个由英文字母组成的字符串转换成指定格式---从右边开始每三个字母用逗号分隔的形式。 package com.string; public class StringBuilderTest { public static void main(String[] args) { // 创建一个空的StringBuilder对象 StringBuilder str = new StringBuilder(); // 追加字符串 str.append(\"jaewkjldfxmopzdm\"); // 从后往前每隔三位插入逗号 for (int i = str.length() - 1, j = 0; i >= 0; i--, j++) { if (j > 0 && j % 3 == 2) { str.insert(i, \",\"); } } // 将StringBuilder对象转换为String对象并输出 System.out.print(str.toString()); } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-08 21:55:04 "},"pages/third-season/thread-safe.html":{"url":"pages/third-season/thread-safe.html","title":"thread-safe 线程安全","keywords":"","body":"thread-safe 线程安全 线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。 百度百科 实现线程安全的三种方式 转自：https://www.cnblogs.com/lizhangyong/p/8029287.html 一个程序在运行起来的时候会转换成进程，通常含有多个线程。 通常情况下，一个进程中的比较耗时的操作（如长循环、文件上传下载、网络资源获取等），往往会采用多线程来解决。 比如显示生活中，银行取钱问题、火车票多个售票窗口的问题，通常会涉及到并发的问题，从而需要多线程的技术。 当进程中有多个并发线程进入一个重要数据的代码块时，在修改数据的过程中，很有可能引发线程安全问题，从而造成数据异常。例如，正常逻辑下，同一个编号的火车票只能售出一次，却由于线程安全问题而被多次售出，从而引起实际业务异常。 [!TIP|style:flat|label:示例] 现在我们就以售票问题来演示线程安全的问题。 在不对多线程数据进行保护的情况下会引发的状况 public class ThreadUnSecurity { static int tickets = 10; class SellTickets implements Runnable { @Override public void run() { // 未加同步时产生脏数据 while(tickets > 0) { System.out.println(Thread.currentThread().getName() + \"--->售出第：\" + tickets + \"票\"); tickets--; try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } if (tickets 售票结束！\"); } } } public static void main(String[] args) { SellTickets sell = new ThreadUnSecurity().new SellTickets(); Thread thread1 = new Thread(sell, \"1号窗口\"); Thread thread2 = new Thread(sell, \"2号窗口\"); Thread thread3 = new Thread(sell, \"3号窗口\"); Thread thread4 = new Thread(sell, \"4号窗口\"); thread1.start(); thread2.start(); thread3.start(); thread4.start(); } } 运行结果： 1号窗口--->售出第：10票 2号窗口--->售出第：10票 3号窗口--->售出第：8票 4号窗口--->售出第：7票 3号窗口--->售出第：6票 4号窗口--->售出第：6票 1号窗口--->售出第：6票 2号窗口--->售出第：6票 3号窗口--->售出第：2票 1号窗口--->售出第：2票 2号窗口--->售出第：2票 4号窗口--->售出第：2票 4号窗口--->售票结束！ 3号窗口--->售票结束！ 2号窗口--->售票结束！ 1号窗口--->售票结束！ 我们可以看出同一张票在不对票数进行保护时会出现同一张票会被出售多次！由于线程调度中的不确定性，读者在演示上述代码时，出现的运行结果会有不同。 为了解决上述脏数据的问题，我为大家介绍3种使用比较普遍的三种同步方式。 第一种实现线程安全的方式: 同步代码块 有synchronized关键字修饰的语句块，即为同步代码块。同步代码块会被JVM自动加上内置锁,从而实现同步。 public class ThreadSynchronizedSecurity { static int tickets = 10; class SellTickets implements Runnable{ @Override public void run() { // 同步代码块 while(tickets > 0) { synchronized (this) { // System.out.println(this.getClass().getName().toString()); if (tickets 售出第：\" + tickets + \" 票\"); tickets--; try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } if (tickets 售票结束！\"); } } } } public static void main(String[] args) { SellTickets sell = new ThreadSynchronizedSecurity().new SellTickets(); Thread thread1 = new Thread(sell, \"1号窗口\"); Thread thread2 = new Thread(sell, \"2号窗口\"); Thread thread3 = new Thread(sell, \"3号窗口\"); Thread thread4 = new Thread(sell, \"4号窗口\"); thread1.start(); thread2.start(); thread3.start(); thread4.start(); } } 输出结果读者可自行调试，不会出现同一张票被出售多次的情况。 第二种实现线程安全的方式: 同步方法 即有synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。 public class ThreadSynchroniazedMethodSecurity { static int tickets = 10; class SellTickets implements Runnable{ @Override public void run() { // 同步方法 while (tickets > 0) { synMethod(); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } if (tickets售票结束\"); } } } synchronized void synMethod() { synchronized (this) { if (tickets 售出第 \" + tickets + \" 票 \"); tickets--; } } } public static void main(String[] args) { SellTickets sell = new ThreadSynchroniazedMethodSecurity().new SellTickets(); Thread thread1 = new Thread(sell, \"1号窗口\"); Thread thread2 = new Thread(sell, \"2号窗口\"); Thread thread3 = new Thread(sell, \"3号窗口\"); Thread thread4 = new Thread(sell, \"4号窗口\"); thread1.start(); thread2.start(); thread3.start(); thread4.start(); } } 读者可自行调试上述代码的运行结果。 第三种实现线程安全的方式: Lock锁机制 通过创建Lock对象，采用lock()加锁，unlock()解锁，来保护指定的代码块。 import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class ThreadLockSecurity { static int tickets = 10; class SellTickets implements Runnable{ Lock lock = new ReentrantLock(); @Override public void run() { // Lock锁机制 while(tickets > 0) { try { lock.lock(); if (tickets 售出第： \"+tickets+\" 票\"); tickets--; } catch (Exception e1) { // TODO Auto-generated catch block e1.printStackTrace(); } finally { lock.unlock(); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } if (tickets 售票结束！\"); } } } public static void main(String[] args) { SellTickets sell = new ThreadLockSecurity().new SellTickets(); Thread thread1 = new Thread(sell, \"1号窗口\"); Thread thread2 = new Thread(sell, \"2号窗口\"); Thread thread3 = new Thread(sell, \"3号窗口\"); Thread thread4 = new Thread(sell, \"4号窗口\"); thread1.start(); thread2.start(); thread3.start(); thread4.start(); } } [!TIP|style:flat|label:总结] 由于synchronized是在JVM层面实现的，因此系统可以监控锁的释放与否； 而ReentrantLock是使用代码实现的，系统无法自动释放锁，需要在代码中的finally子句中显式释放锁lock.unlock()。 另外，在并发量比较小的情况下，使用synchronized是个不错的选择；但是在并发量比较高的情况下，其性能下降会很严重，此时ReentrantLock是个不错的方案。 补充：　　 在使用synchronized 代码块时,可以与wait()、notify()、notifyAll()一起使用，从而进一步实现线程的通信。 其中，wait()方法会释放占有的对象锁，当前线程进入等待池，释放cpu,而其他正在等待的线程即可抢占此锁，获得锁的线程即可运行程序；线程的sleep()方法则表示，当前线程会休眠一段时间，休眠期间，会暂时释放cpu，但并不释放对象锁，也就是说，在休眠期间，其他线程依然无法进入被同步保护的代码内部，当前线程休眠结束时，会重新获得cpu执行权,从而执行被同步保护的代码。 wait()和sleep()最大的不同在于wait()会释放对象锁，而sleep()不会释放对象锁。 notify()方法会唤醒因为调用对象的wait()而处于等待状态的线程，从而使得该线程有机会获取对象锁。调用notify()后，当前线程并不会立即释放锁，而是继续执行当前代码，直到synchronized中的代码全部执行完毕，才会释放对象锁。JVM会在等待的线程中调度一个线程去获得对象锁，执行代码。 需要注意的是，wait()和notify()必须在synchronized代码块中调用。 notifyAll()是唤醒所有等待的线程。 接下来，我们通过下一个程序，使得两个线程交替打印“A”和“B”各10次。请见下述代码： public class ThreadDemo { static final Object obj = new Object(); //第一个子线程 static class ThreadA implements Runnable{ @Override public void run() { int count = 10; while(count > 0) { synchronized (ThreadDemo.obj) { System.out.println(\"A-----\" + count); count--; synchronized (ThreadDemo.obj) { //notify()方法会唤醒因为调用对象的wait()而处于等待状态的线程，从而使得该线程有机会获取对象锁。 //调用notify()后，当前线程并不会立即释放锁，而是继续执行当前代码，直到synchronized中的代码全部执行完毕， ThreadDemo.obj.notify(); try { ThreadDemo.obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } } static class ThreadB implements Runnable{ @Override public void run() { int count = 10; while(count > 0) { synchronized (ThreadDemo.obj) { System.out.println(\"B-----\" + count); count--; synchronized (ThreadDemo.obj) { //notify()方法会唤醒因为调用对象的wait()而处于等待状态的线程，从而使得该线程有机会获取对象锁。 //调用notify()后，当前线程并不会立即释放锁，而是继续执行当前代码，直到synchronized中的代码全部执行完毕， ThreadDemo.obj.notify(); try { ThreadDemo.obj.wait(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } } } public static void main(String[] args) { new Thread(new ThreadA()).start(); new Thread(new ThreadB()).start(); } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-07 22:00:55 "},"pages/third-season/wrapper-class.html":{"url":"pages/third-season/wrapper-class.html","title":"包装类","keywords":"","body":"包装类 基本数据类型(int、float、double、boolean、char等)是不具备对象的特性的。比如不能调用方法、功能简单。 为了使基本数据类型也 具备对象的特性， Java 为每个基本数据类型都提供了一个 包装类，这样我们就可以像操作对象那样来操作基本数据类型。 基本类型和包装类之间的对应关系： 基本类型 对应的包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 包装类主要提供了两大类方法： 1、将本类型和其他基本类型进行转换的方法。 2、将字符串和本类型及包装类互相转换的方法。 以 Integer 包装类为例，来看下包装类的特性。 Integer 包装类的构造方法： Integer(int value) 创建一个Integer对象，表示指定的int值 Integer(String s) 创建一个Integer对象，表示String参数所指示的int值 int i = 2; // 定义Integer包装类对象，值为5 Integer m = new Integer(5); // 定义Integer包装类对象，值为8 Integer n = new Integer(\"8\"); Integer包装类的常用方法： 方法名 返回值 说明 byteValue() byte 将Integer转为byte类型 doubleValue() double 转为double类型 floatValue() float 转为float类型 intValue() int 转为int类型 longValue() long 转为long类型 parseInt(String s) static int 将字符串转为int类型 toString() String 转为字符串类型 valueOf(String s) static Integer 将字符串转换为Integer类型 public class WrapperClass { public static void main(String[] args) { int i = 2; Integer m = new Integer(5); Integer n = new Integer(\"8\"); System.out.println(i); System.out.println(m); System.out.println(n); // 定义int类型变量，值为86 int score1 = 86; // 创建Integer包装类对象，表示变量score1的值 Integer score2 = new Integer(score1); // 将Integer包装类转换为double类型 double score3 = score2.doubleValue(); // 将Integer包装类转换为float类型 float score4 = score2.floatValue(); // 将Integer包装类转换为int类型 int score5 = score2.intValue(); System.out.println(\"Integer包装类：\" + score2); System.out.println(\"double类型：\" + score3); System.out.println(\"float类型：\" + score4); System.out.println(\"int类型：\" + score5); } } 运行结果： 2 5 8 Integer包装类：86 double类型：86.0 float类型：86.0 int类型：86 基本类型和包装类之间的转换 基本类型和包装类之间经常需要互相转换，以 Integer 为例（其他几个包装类的操作与此雷同）： // 定义Integer包装类对象，值为3 Integer a = new Integer(3); // 将对象和基本类型进行运算 int b = a + 5; 在 JDK1.5 引入自动装箱和拆箱的机制后，包装类和基本类型之间的转换就更加轻松便利了。 那什么是装箱和拆箱呢？我们分别来看下 装箱：把基本类型转换成包装类，使其具有对象的性质，又可分为手动装箱和自动装箱 // 定义一个int类型值 int i = 10; // 手动装箱 Integer x = new Integer(i); // 自动装箱 Integer y = i; 拆箱：和装箱相反，把包装类对象转换成基本类型的值，又可分为手动拆箱和自动拆箱 // 定义一个Integer包装类对象，值为8 Integer j = new Integer(8); // 手动拆箱为int类型 int m = j.intValue(); // 自动拆箱为int类型 int n = j; [!TIP|style:flat|label:总结] Integer 类型可以自动转化为 int 基本类型 int 类型对应的包装类是 java.lang.Integer long 类型可以自动转化为 Long类型 基本类型和字符串之间的转换 在程序开发中，我们经常需要在基本数据类型和字符串之间进行转换。 其中，基本类型转换为字符串有三种方法： 1、使用包装类的 toString() 方法 2、使用String类的 valueOf() 方法 3、用一个空字符串加上基本类型，得到的就是基本类型数据对应的字符串 // 将基本类型转化为字符串 int c = 10; String str1 = Integer.toString(c); String str2 = String.valueOf(c); String str3 = c + \"\"; 再来看，将字符串转换成基本类型有两种方法： 1、调用包装类的 parseXxx 静态方法 2、调用包装类的 valueOf() 方法转换为基本类型的包装类，会自动拆箱 // 将字符串转化为基本类型 String str = \"8\"; int d = Integer.parseInt(str); int e = Integer.valueOf(str); PS：其他基本类型与字符串的相互转化这里不再一一列出，方法都类似。 [!TIP|style:flat|label:总结] 每一个基本数据类型，都对应一个包装类 包装类都在 java.lang 包中 包装类提供了在不同类型间进行转换的方法 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-08 22:29:51 "},"pages/third-season/date.html":{"url":"pages/third-season/date.html","title":"Date和SimpleDateFormat类","keywords":"","body":"Date 和 SimpleDateFormat 类 Date类 java.util 包中的 Date 类，这个类最主要的作用就是获取当前时间。 // 使用默认的构造方法创建Date对象 Date d = new Date(); // 输出Date对象 System.out.println(d); 使用 Date 类的默认无参构造方法创建出的对象就代表当前时间。 Mon Apr 08 22:34:51 CST 2019 其中， Mon 代表 Monday (星期一)， Apr 代表 April (四月)， 08 代表 08 号， CST 代表 China Standard Time (中国标准时间，也就是北京时间，东八区)。 SimpleDateFormat类 java.text 包中的 SimpleDateFormat类 1、使用 format() 方法将日期转换为指定格式的文本 import java.util.*; import java.text.*; public class DateTest { public static void main(String[] args) { // 创建Date对象，表示当前时间 Date d = new Date(); // 创建SimpleDateFormat对象，指定目标格式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); // 调用format()方法，格式化时间，转化为指定格式字符串 String today = sdf.format(d); // 输出转换后的字符串 System.out.print(today); } } 代码中的 “yyyy-MM-dd HH:mm:ss” 为预定义字符串， yyyy 表示四位年， MM 表示两位月份， dd 表示两位日期， HH 表示小时(使用24小时制)， mm 表示分钟， ss 表示秒，这样就指定了转换的目标格式，最后调用 format() 方法将时间转换为指定的格式的字符串。 运行结果： 2019-04-08 22:41:48 2、使用 parse() 方法将文本转换为日期 import java.util.Date; import java.text.ParseException; import java.text.SimpleDateFormat; public class DateParseTest { public static void main(String[] args) { // 创建日期格式的字符串 String day = \"2019年04月08日 22:44:23\"; // 创建SimpleDateFormat对象，指定字符串的日期格式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); // 调用parse()方法，将字符串转化为日期 try { Date date = sdf.parse(day); // 输出转换后的时间 System.out.println(\"parse后的时间：\" + date); } catch (ParseException e) { e.printStackTrace(); System.out.println(\"parse(\" + day + \")失败\"); } } } 代码中的 “yyyy年MM月dd日 HH:mm:ss” 指定了字符串的日期格式，调用 parse() 方法将文本转换为日期。 运行结果： parse后的时间：Mon Apr 08 22:44:23 CST 2019 [!WARNING|style:flat|label:注意] 调用 SimpleDateFormat 对象的 parse() 方法时可能会出现转换异常，即 ParseException ，因此需要进行异常处理 使用 Date 类时需要导入 java.util 包，使用 SimpleDateFormat 时需要导入 java.text 包 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-08 22:53:37 "},"pages/third-season/calendar.html":{"url":"pages/third-season/calendar.html","title":"Calendar类的应用","keywords":"","body":"Calendar类 Date 类最主要的作用就是获得当前时间，同时这个类里面也具有设置时间以及一些其他的功能，但是由于本身设计的问题，这些方法却遭到众多批评，不建议使用，更推荐使用 Calendar 类进行时间和日期的处理。 java.util.Calendar 类是一个抽象类，可以通过调用 getInstance() 静态方法获取一个 Calendar 对象，此对象已由当前日期时间初始化，即默认代表当前时间，如 Calendar c = Calendar.getInstance(); 那么如何使用 Calendar 获取年、月、日、时间等信息呢？我们来看下面的代码： import java.util.Calendar; public class CalenderTest { public static void main(String[] args) { // 创建Canlendar对象 Calendar c = Calendar.getInstance(); int year = c.get(Calendar.YEAR); int month = c.get(Calendar.MONTH) + 1; int day = c.get(Calendar.DAY_OF_MONTH); int hour = c.get(Calendar.HOUR_OF_DAY); int minute = c.get(Calendar.MINUTE); int second = c.get(Calendar.SECOND); System.out.println(\"Current time: \" + year + \"-\" + month + \"-\" + day + \" \" + hour + \":\" + minute + \":\" + second); } } 其中，调用 Calendar 类的 getInstance() 方法获取一个实例，然后通过调用 get() 方法获取日期时间信息，参数为需要获得的字段的值， Calendar.YEAR 等为 Calendar 类中定义的静态常量。 运行结果： Current time: 2019-4-8 23:5:14 Calendar 类提供了 getTime() 方法，用来获取 Date 对象，完成 Calendar 和 Date 的转换，还可通过 getTimeInMillis() 方法，获取此 Calendar 的时间值，以毫秒为单位。如下所示： // 将Calendar对象转化为Date对象 Date date = c.getTime(); // 获取当前毫秒数 Long msec = c.getTimeInMillis(); System.out.println(\"Current time: \" + date); System.out.println(\"Current millis: \" + msec); 运行结果： Current time: Mon Apr 08 23:10:08 CST 2019 Current millis: 1554736208939 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-08 23:10:40 "},"pages/third-season/math.html":{"url":"pages/third-season/math.html","title":"Math类","keywords":"","body":"Math类 Math 类位于 java.lang 包中，包含用于执行基本数学运算的方法， Math 类的所有方法都是静态方法，所以使用该类中的方法时，可以直接使用类名.方法名，如： Math.round(); 方法名 返回值 说明 round() long 返回四舍五入后的整数 floor() double 返回小于参数的最大整数 ceil() double 返回大于参数的最小整数 random() double 返回[0, 1)之间的随机浮点数 public class MathTest { public static void main(String[] args) { double a = 23.92; int b = (int) a; System.out.println(a +\"强制int类型转换：\" + b); long c = Math.round(a); System.out.println(\"round(\"+ a +\")四舍五入：\" + c); double d = Math.floor(a); System.out.println(\"floor(\"+ a +\")：\" + d); double e = Math.ceil(a); System.out.println(\"ceil(\"+ a +\")：\" + e); double f = Math.random(); System.out.println(\"random()：\" + f); } } 运行结果： 23.92强制int类型转换：23 round(23.92)四舍五入：24 floor(23.92)：23.0 ceil(23.92)：24.0 random()：0.5485492457892083 [!TIP|style:flat|label:PS] Math 类还提供了许多其他方法，各位小伙伴们可以注意关注 wiki ，查阅更多信息。 练习 public class MathTest2 { public static void main(String[] args) { // 定义一个整型数组，长度为10 int[] nums = new int[10]; // 通过循环给数组赋值 for (int i = 0; i © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-09 23:41:38 "},"pages/third-season/set.html":{"url":"pages/third-season/set.html","title":"集合框架","keywords":"","body":"Java中的集合框架 集合的概念 现实生活中：把很多的事物凑在一起。比如购物车是商品的集合，军队是军人的集合等。 数学中的集合：具有共同属性的事物的总体。比如有理数，整数等。 Java中的集合类：是一种工具类，就像是容器，储存任意数量的具有共同属性的对象。 集合的作用 在类的内部，对数据进行组织； 简单而快捷的搜索大数量的条目； 有的集合接口，提供了一系列排列有序的元素，并且可以在序列中间快速的插入或者删除有关元素。 有的集合接口，提供了映射关系，可以通过关键字key去快速查找到对应的唯一对象，而这个关键字可以是任意类型。 与数组对比 数组长度固定，超出长度时，需要重新创建拷贝数据到新的数据。 集合：长度可以根据数据数量自动改变。 [!TIP|style:flat|label:总结] 数组的长度固定，集合长度可变。 数组只能通过下标访问元素，类型固定，查找数据需要逐个遍历。而有的集合可以通过任意类型查找所映射的具体对象。 Java集合框架体系结构 主要由两大家族（两个根接口）组成：Collection、Map 1、Collection子接口：List、Queue、Set List（序列）、Queue（队列）：元素排列有序，且可以重复。 Set（集）：元素无序，且不可重复。 List与Set较为常用。 List中一个很重要的实现类ArrayList（数组序列）。 Queue中一个重要的实现类LinkedList（链表），同时也是List的实现类。 Set中一个重要的实现类HashSet（哈希集）。 2、Map Map也有很多子接口。 Map中一个很重要的实现类：HashMap（哈希表）。 [!TIP|style:flat|label:数据存储] Collection中存储一个个独立的对象。 Map内以Key、Value键值对形式存储数据，即一个Entry（键值对，Map的内部类）类的实例。Key、Value可以是任意类型的对象。 Collection可以想象为单身宿舍，里面存储的一个一个的光棍。 Map内存储的一对一对的夫妇。 Collection接口、子接口以及实现类 Collection接口 是List、Set和Queue接口的父接口。 定义了可用于操作List、Set、Queue的方法：增删改查。 List接口及其实现类：ArrayList List是元素有序，并且可以重复的集合，被称为序列。 List可以精确的控制每个元素的插入位置，或删除某个指定位置元素。 ArrayList：数组序列，是List的一个重要实现类。 ArrayList底层是由数组实现的。 [!NOTE|label:练习-模拟学生选课功能] 选择课程（往集合中添加课程） 删除所选的某门课程（删除集合中的元素） 查看所选课程 修改所选课程 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-10 22:07:55 "}}