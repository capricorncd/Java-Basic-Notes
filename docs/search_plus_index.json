{"./":{"url":"./","title":"Java","keywords":"","body":"Java Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。 Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。 Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。 Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等 Java基础文档 入口：https://capricorncd.github.io/Java-Notes/ Java发展历程 1995由Sun公司推出，2009被Oracle收购。 Java平台应用 核心概念：JVM/JDK/JRE [!TIP|label:JVM|style:flat] Java Virtual Machine [!TIP|label:JDK|style:flat] Java Development Kit (Java开发工具包) [!TIP|label:JRE|style:flat] Java Runtime Environment (Java运行时环境) Java 开发环境搭建 1、安装JDK https://www.oracle.com/technetwork/java/javase/downloads/index.html JDK8 https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html [!TIP|style:flat] Java库文件，以 .jar 结尾 2、window 10 配置环境变量（系统变量） # 配置JDK安装路径 JAVA_HOME C:\\Program Files\\Java\\jdk1.8.0_172 # 配置类库文件的位置 CLASSPATH .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar # 配置JDK命令文件的位置 path C:\\ProgramFiles\\Java\\jdk1.8.0_172\\bin C:\\Program Files\\Java\\jdk1.8.0_172\\bin\\jre\\bin 3、Mac 直接装jdk-8u201-macosx-x64.dmg就可以了。 使用工具开发Java程序 HelloWorld.java public class HelloWorld { public static void main(String[] args) { System.out.println(\"Welcome to Java world.\"); } } 使用bash，找到文件路径，执行 javac HelloWorld.java 此时，会在当前位置生产一个HelloWorld.class的字节码文件。 # 执行字节码文件，注意不能跟后缀名.class java HelloWorld # Welcome to Java world. 使用IDE开发 集成开发环境（IDE）是一类软件 将程序开发环境和程序调试环境集合在一起，提高开发效率。 Eclipse 开源免费的。下载地址 https://www.eclipse.org/downloads/ MyEclipse MyEclipse是对Eclipse的扩展，是一个十分优秀的用于开发Java、JavaEE的Eclipse插件集合。 https://www.myeclipsecn.com 开发流程 以Eclipse为例 1 创建Java项目 file -> New -> Java Project # Project name: hello 2 创建程序包 # src 目录 New -> Package # com.hello 3 编写Java源程序 com.hello -> New -> Class > Name: HelloTest IDE自动生成：HelloTest.java package com.hello; public class HelloTest { } [!WARNING|style:flat|label:注意] 类名 class HelloTest 一定要与文件名 HelloTest.java 相同。 如下图： 4 运行Java程序 代码编辑拦，空白处鼠标右键 -> Run As -> Java Application ... 或者点击编辑器左上角的\"播放\"图标，run ... 程序的移植 从公司拷回屋里继续写... 拷贝项目代码 -> 到家，开电脑，打开软件 -> File -> Import -> General/Existing Project into Workspace -> Next -> Select root directory: [Broser] -> 找到文件 -> Finish 来自巨人的经验 多练、多问、自己动手，调试错误、复习和总结。 学虽容易，学好不易，且学且珍惜。 原教程出处 https://www.imooc.com/learn/85 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 20:56:50 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/first-season/variable-and-constant.html":{"url":"pages/first-season/variable-and-constant.html","title":"变量与常量","keywords":"","body":"变量与常量 Java关键字 Java 关键字是区分大小写 Java标识符 标识符就是用于给 Java 程序中变量、类、方法等命名的符号。 使用标识符时，需要遵守几条规则： 1、标识符可以由字母、数字、下划线（_）、美元符（$）组成，但不能包含 @、%、空格等其它特殊字符，不能以数字开头。譬如：123name 就是不合法。 2、标识符不能是 Java 关键字和保留字（ Java 预留的关键字，以后的升级版本中有可能作为关键字），但可以包含关键字和保留字。如：不可以使用 void 作为标识符，但是 Void 可以。 3、标识符是严格区分大小写的。 4、标识符的命名最好能反映出其作用，做到见名知意。 变量 在 Java 中，我们通过三个元素描述变量：变量类型、变量名以及变量值。 int a = 30; String b = \"this is String\"; 通常： 1、变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 createUserInfo。 2、变量命名时，尽量简短且能清楚的表达变量的作用，做到见名知意。如：定义变量名 studentName 保存“学生姓名”信息。 3、Java 变量名的长度没有限制，但 Java 语言是区分大小写的，所以price和Price 是两个完全不同的变量！ public class HelloWorld { public static void main(String[] args) { int hobby = 9999; System.out.println(hobby); } } Java中的数据类型 Java 语言是一种强类型语言。通俗点说就是，在 Java 中存储的数据都是有类型的，而且必须在编译时就确定其类型。 Java 中有两类数据类型： [!WARNING|style:flat|label:注意] 在Java里，基本数据类型 变量存的是 数据本身，而 引用类型 变量存的是保存数据的 空间地址。 数据类型 说明 字节 应用 示例 int 整型 4 整数，如年龄/个数等 int age=21; double 双精度浮点型 8 小数，如商品价格/成绩平均分等 double price=21.5; float 单精度浮点型 4 小数，如身高等 float height=180.3f; char 字符型 2 单个字符，如性别男/女 char gander='男'; boolean 布尔型 1 表示真true或假false boolean flag=true; [!TIP|style:flat] float变量赋值时，在数值后面添加字母 f。 char变量赋值时，使用单引号 '。 Java中变量的使用规则 Java 中的变量需要先声明后使用 变量使用时，可以声明变量的同时进行初始化 变量中每次只能赋一个值，但可以修改多次 main 方法中定义的变量必须先赋值，然后才能输出 String a; System.out.println(a); // error [!WARNING|style:flat|label:注意] 虽然语法中不会提示错误，但在实际开发中，变量名不建议使用中文，容易产生安全隐患。譬如后期跨平台操作时出现乱码等等。 Java中的自动类型转换 自动类型转换: int a = 89; double b = a; System.out.println(b); // 89.0 自动类型转换是需要满足特定的条件: 1、目标类型能与源类型兼容，如 double 型兼容 int 型，但是 char 型不能兼容 int 型。 2、目标类型大于源类型，如 double 类型长度为 8 字节， int 类型为 4 字节，因此 double 类型的变量里直接可以存放 int 类型的数据，但反过来就不可以。 Java中的强制类型转换 double average = 74.9; int average2 = (int)average; System.out.println(average); // 74.9 System.out.println(average2); // 74 [!WARNING|style:flat|label:注意] 强制类型转换可能会造成数据的丢失 Java常量的应用 语法 final 常量名 = 值; 程序中使用常量可以提高代码的可维护性。 常量名一般使用大写字符。 Java中使用注释 在编写程序时，经常需要添加一些注释，用以描述某段代码的作用。 一般来说，对于一份规范的程序源代码而言，注释应该占到源代码的 1/3 以上。因此，注释是程序源代码的重要组成部分。 Java 中注释有三种类型：单行注释、多行注释、文档注释。 package com.test /** * 这是文档注释 * @author authorName * @version v1.0.0 */ public class TestDemo { /* * 这是多行注释 * 可以包含多行内容 */ public static void main(String[] args) { // 这是单行注释 System.out.println(\"Hello World\"); } } 我们可以通过 javadoc 命令从文档注释中提取内容，生成程序的 API 帮助文档。 javadoc -d doc TestDemo.java 使用文档注释时还可以使用 javadoc 标记，生成更详细的文档信息： @author 标明开发该类模块的作者 @version 标明该类模块的版本 @see 参考转向，也就是相关主题 @param 对方法中某参数的说明 @return 对方法返回值的说明 @exception 对方法可能抛出的异常进行说明 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 20:52:16 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/first-season/operator.html":{"url":"pages/first-season/operator.html","title":"运算符","keywords":"","body":"运算符 算术运算符 赋值运算符 比较运算符 逻辑运算符 条件运算符 算术运算符 算术运算符主要用于进行基本的算术运算，如加法、减法、乘法、除法等。 赋值运算符 赋值运算符是指为变量或常量指定数值的符号。如可以使用 “=” 将右边的表达式结果赋给左边的操作数。 比较运算符 比较运算符用于判断两个数据的大小，例如：大于、等于、不等于。比较的结果是一个布尔值（ true 或 false ）。 1、>、、>=、 只支持左右两边操作数是数值类型 2、==、!= 两边的操作数既可以是数值类型，也可以是引用类型 逻辑运算符 逻辑运算符主要用于进行逻辑运算。Java 中常用的逻辑运算符如下表所示： 我们可以从“投票选举”的角度理解逻辑运算符： 1、与：要求所有人都投票同意，才能通过某议题 2、或：只要求一个人投票同意就可以通过某议题 3、非：某人原本投票同意，通过非运算符，可以使其投票无效 4、异或：有且只能有一个人投票同意，才可以通过某议题 当使用逻辑运算符时，我们会遇到一种很有趣的“短路”现象。 譬如：( one > two ) && ( one two 运行结果为 false , 则系统就认为已经没有必要执行右侧的 one 同理，在( one > two ) || ( one 条件运算符 条件运算符（ ? : ）也称为 “三元运算符”。 语法： 布尔表达式 ？表达式1 ：表达式2 运算符的优先级 所谓优先级，就是在表达式中的运算顺序。 优先级 运算符 1 () 2 ! +正 -负 ++ -- 3 * / % 4 +加 -减 5 >= 6 == != 7 ^ 8 && 9 10 ? :三元运算符 11 = += -= *= /= %= 级别为 1 的优先级最高，级别 11 的优先级最低。 ( 11+ 3* 8 ) / 4 % 3; // 2 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 23:52:20 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/first-season/flow-control-statement.html":{"url":"pages/first-season/flow-control-statement.html","title":"流程控制语句","keywords":"","body":"流程控制语句 if, if else if (BooleanConditionalExpression) { // do something } else { // do something } if (BooleanConditionalExpression1) { // do something } else if (BooleanConditionalExpression2) { // do something } else { // do something } switch switch (Expression) { case Value1: // do something break; case Value1: // do something break; default: // do something } while int i = 1; while (i for for (循环变量初始化; 循环条件; 循环变量变化) { // 循环操作 } 执行过程： 1、执行循环变量初始化部分，设置循环的初始状态，此部分在整个循环中只执行一次 2、进行循环条件的判断，如果条件为 true ，则执行循环体内代码；如果为 false ，则直接退出循环 3、执行循环变量变化部分，改变循环变量的值，以便进行下一次条件判断 4、依次重新执行、、，直到退出循环 特点： 相比 while 和 do...while 语句结构更加简洁易读 注意： 1、for 关键字后面括号中的三个表达式必须用 “;” 隔开，三个表达式都可以省略，但 “;” 不能省略。 a. 省略“循环变量初始化”，可以在 for 语句之前由赋值语句进行变量初始化操作，如: int i = 0; for (; i b. 省略“循环条件”，可能会造成循环将一直执行下去，也就是我们常说的“死循环”现象，如: for (int i = 0; ; i++) { // do something } 在编程过程中要避免“死循环”的出现，因此，对于上面的代码可以在循环体中使用 break 强制跳出循环。 c. 省略“循环变量变化”，可以在循环体中进行循环变量的变化，如： for (int i = 0; i 2、for 循环变量初始化和循环变量变化部分，可以是使用 “,” 同时初始化或改变多个循环变量的值，如： for (int i = 1, j = 5; i 代码中，初始化变量部分同时对两个变量 i 和 j 赋初值，循环变量变化部分也同时对两个变量进行变化。 3、循环条件部分可以使用逻辑运算符组合的表达式，表示复杂判断条件，但一定注意运算的优先级，如： for (int i = 1; i 代码中，必须同时满足变量 i 小于 10 ，并且 i 不等于 5 时才会进行循环，输出变量 i 的值。 break for (int i = 0; i continue for (int i = 0; i 编程题 /* * 为指定成绩加分，直到分数大于等于 60 为止， * 输出加分前和加分后的成绩，并统计加分的次数 */ Test1.java package com.test1; import java.util.Scanner; /* * 为指定成绩加分，直到分数大于等于 60 为止， * 输出加分前和加分后的成绩，并统计加分的次数 */ /* * 使用Scanner工具类来获取用户输入的成绩信息 * Scanner类位于java.util包中，使用时需要导入 * 步骤： * 1.导入java.util.Scanner * 2.创建Scanner对象 * 3.接收并保存用户输入的值 */ public class Test1 { public static void main(String[] args) { // create Scanner Object Scanner input = new Scanner(System.in); // notice // println输出后会换行，print不会 System.out.print(\"请输入考试成绩（整数）：\"); // score // get user input score, and save to variable int score = input.nextInt(); // count int count = 0; System.out.println(\"origin score: \" + score); while (score /* * 求3个班级，各4名学生的平均成绩 */ Test2.java package com.test2; import java.util.Scanner; /* * 求3个班级，各4名学生的平均成绩 */ public class Test2 { public static void main(String[] args) { Scanner input = new Scanner(System.in); int classNum = 3; int studentNum = 4; int score; double sum; double avgs; for (int i = 1; i © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 23:53:22 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/first-season/array.html":{"url":"pages/first-season/array.html","title":"数组","keywords":"","body":"数组 int[] scores = { 1, 2, 3, 4, 5, 6, 7 } System.out.println(scores[2]); // 3 声明数组 语法： 数据类型[ ] 数组名； // 或者 数据类型 数组名[ ]； 其中，数组名可以是任意合法的变量名，如： // 存储学生成绩的数组，类型为整型 int[] scores; // 存在身高的数组，类型为浮点型 double height[]; // 存储学生姓名的数组，类型为字符串 String[] names; 分配空间 简单地说，就是指定数组中最多可存储多少个元素 语法： 数组名 = new 数据类型 [ 数组长度 ]; 其中，数组长度就是数组中能存放元素的个数，如： scores = new int[5]; height = new double[5]; names = new String[5]; 也可以将上面的两个步骤合并，在声明数组的同时为它分配空间 int[] scores = new int[5]; 赋值 scores[0] = 100; scores[1] = 99; 处理数组中数据 System.out.println(scores[1]); // 99 同时声明数组、分配空间和赋值： int[] scores = {89, 90, 100, 78}; public class HelloWorld { public static void main(String[] args) { // 定义一个长度为5的字符串数组，保存考试科目信息 String[] subjects = new String[5]; // 分别为数组中的元素赋值 subjects[0] = \"Oracle\"; subjects[1] = \"PHP\"; subjects[2] = \"Linux\"; subjects[3] = \"Java\"; subjects[4] = \"HTML\"; System.out.println(\"数组中第4个科目为：\" + subjects[3]); } } 例子： // error: // Cannot define dimension expressions when an array initializer is provided int[ ] score = new int[ 4 ] { 90, 12, 34, 77 }; // error: // Variable must provide either dimension expressions // or an array initializer int[ ] score = new int[ ]; // right int score[ ] = new int[ ] { 34, 90, 87, 54, 24 }; 循环操作 int[] arr = { 34, 53, 98, 23}; for (int i = 0; i 获取数组的长度语法 数组名.length 数组下标的范围是 0 至 数组长度-1 ，如果越界访问，就会报错。 // Array.java Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 4 at com.array.Array.main(Array.java:15) 练习： 输出数组中的最大值、最小值和平均值 public class Array { public static void main(String[] args) { // 定义一个整型数组，并赋初值 int[] nums = new int[] { 61, 23, 4, 74, 13, 148, 20 }; int max = nums[0]; // 假定最大值为数组中的第一个元素 int min = nums[0]; // 假定最小值为数组中的第一个元素 double sum = 0;// 累加值 double avg = 0;// 平均值 for (int i = 0; i 0 && nums[i] > max) { max = nums[i]; } // 如果当前值小于min，则替换min的值 if (i > 0 && nums[i] 使用 Arrays 类操作 Java 中的数组 Arrays 类是 Java 中提供的一个工具类，在 java.util 包中。该类中包含了一些方法用来直接操作数组，比如可直接实现数组的排序、搜索等 排序 sort() // 语法： Arrays.sort(数组名); public class Array { public static void main(String[] args) { // 定义一个整型数组，并赋初值 int[] nums = new int[] { 61, 23, 4, 74, 13, 148, 20 }; Arrays.sort(nums); System.out.println(\"排序后的首尾数为：\" + nums[0] + \", \" + nums[nums.length - 1]); System.out.println(\"toString: \" + Arrays.toString(nums)); } } 将数组转换为字符串 toString() // 语法： Arrays.toString(数组名); foreach foreach 并不是 Java 中的关键字，是 for 语句的特殊简化版本，在遍历数组、集合时， foreach 更简单便捷。 [!TIP|style:flat|label:语法] for (元素类型 元素变量 : 遍历对象) { // do something } for (int i : nums) { System.out.println(\"print by foreach: \" + i); } 二维数组 声明数组/分配空间 数据类型[][] 数组名 = new 数据类型[行数][列数]; 或 数据类型[][] 数组名; 数组名 = new 数据类型[行数][列数]; CODE Array.java package com.array; import java.util.Arrays; /* public class Array { public static void main(String[] args) { // right: int score[] = new int[]{45, 56, 76, 23}; // error: // Cannot define dimension expressions // when an array initializer is provided // int score[] = new int[4]{45, 56, 76, 23}; // error: // Variable must provide either dimension expressions // or an array initializer // int[ ] score = new int[ ]; System.out.println(score[4]); } } */ /* public class Array { public static void main(String[] args) { // 定义一个整型数组，并赋初值 int[] nums = new int[] { 61, 23, 4, 74, 13, 148, 20 }; int max = nums[0]; // 假定最大值为数组中的第一个元素 int min = nums[0]; // 假定最小值为数组中的第一个元素 double sum = 0;// 累加值 double avg = 0;// 平均值 for (int i = 0; i 0 && nums[i] > max) { max = nums[i]; } // 如果当前值小于min，则替换min的值 if (i > 0 && nums[i] Test.java package com.array; import java.util.Arrays; /* * 创建指定长度的 int 型数组， * 并生成 100 以内随机数为数组中的每个元素赋值， * 然后输出数组 */ //public class Test { // public static void main(String[] args) { // Test ts = new Test(); // // create array // int[] arr = ts.createArray(8); // // System.out.println(Arrays.toString(arr)); // } // // public int[] createArray(int length) { // int[] arr = new int[length]; // for (int i = 0; i = 3) break; if (scores[i] >= 0 && scores[i] arr[i]) { temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } return arr; } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 21:53:10 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/first-season/function.html":{"url":"pages/first-season/function.html","title":"方法","keywords":"","body":"方法 语法 访问修饰符 返回值类型 方法名(参数列表) { 方法体 } 访问修饰符： 方法允许被访问的权限范围，可以是 public、protected、private 甚至可以省略。其中 public 表示该方法可以被其他任何代码调用。 返回值类型： 方法返回值的类型，如果方法不返回任何值，则为 void；如果有返回值，则需要指定返回值的类型，并且在方法体中使用 return 语句返回值。 方法名： 定义的方法的名字，必须使用合法的标识符。 参数列表： 传递给方法的参数列表，参数可以有多个，多个参数间以逗号隔开，每个参数由参数类型和参数名组成，以空格隔开。 根据方法是否带参、是否带返回值，可将方法分为四类: Ø 无参无返回值方法 Ø 无参带返回值方法 Ø 带参无返回值方法 Ø 带参带返回值方法 public void print(String str) { System.out.println(str); } 例子 // Func.java public class Func { // 定义print方法 public void print(String str) { System.out.println(str); } public static void main(String[] args) { // 创建Func对象 Func fn = new Func(); // 调用print方法 fn.print(\"Hello world\"); } } 无参带返回值方法 public int sum() { int a = 1; int b = 3; return a + b; } 1、如果方法的返回类型为 void ，则方法中不能使用 return 返回值！ 2、方法的返回值最多只能有一个，不能返回多个值。 3、方法返回值的类型必须兼容，例如，如果返回值类型为 int ，则不能返回 String 型值。 带参无返回值方法 public int sum(int a, int b) { System.out.println(a + b); } 1、调用带参方法时，必须保证实参的数量、类型、顺序与形参一一对应 2、调用方法时，实参不需要指定数据类型 3、方法的参数可以是基本数据类型，如 int、double 等，也可以是引用数据类型，如 String、数组等 4、当方法参数有多个时，多个参数间以逗号分隔。 带参有返回值方法 public int sum(int a, int b) { return a + b; } Java 中方法的重载 [!TIP|style:flat|label:什么是方法的重载呢？] 如果同一个类中包含了两个或两个以上方法名相同、方法参数的个数、顺序或类型不同的方法，则称为方法的重载，也可称该方法被重载了。如下所示 4 个方法名称都为 show ，但方法的参数有所不同，因此都属于方法的重载： // 无参数方法 public void show() { System.out.println(\"not arguments\"); } // 重载show方法，一个字符串参数 public void show(String name) { System.out.println(\"argument name: \" + name); } // 重载show方法，两个参数 public void show(String name, int age) { System.out.println(name + \" is \" + age + \" years old\"); } // 重载show方法，两个参数顺序不同 public void show(int age, String name) { System.out.println(\"The \" + age + \"-year-old people is \" + name + \".\"); } [!TIP|style:flat|label:如何区分调用的是哪个重载方法呢？] 当调用被重载的方法时， Java 会根据参数的个数和类型来判断应该调用哪个重载方法，参数完全匹配的方法将被执行。如： public static void main(String[] args) { Func fn = new Func(); fn.show(); // 调用无参数的show方法 fn.show(\"Juny\"); // 调用带有一个参数的show方法 fn.show(\"Juny\", 15); // 调用带有字符串+整型参数的show方法 } 判断方法重载的依据： 1、必须是在同一个类中 2、方法名相同 3、方法参数的个数、顺序或类型不同 4、与方法的修饰符或返回值没有关系 Test.java package com.test; import java.util.Arrays; /* * 创建指定长度的 int 型数组， * 并生成 100 以内随机数为数组中的每个元素赋值， * 然后输出数组 */ public class Test { public static void main(String[] args) { Test ts = new Test(); // create array int[] arr = ts.createArray(8); System.out.println(Arrays.toString(arr)); } public int[] createArray(int length) { int[] arr = new int[length]; for (int i = 0; i CODE Func.java package com.array; public class Func { public void print(String str) { System.out.println(str); } public int sum() { int a = 1; int b = 3; return a + b; } public static void main(String[] args) { Func f = new Func(); f.print(\"Hello world\" + f.sum()); } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 21:56:18 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/second-season/class-and-object.html":{"url":"pages/second-season/class-and-object.html","title":"类与对象","keywords":"","body":"类和对象 面向对象 1、对象的概念 2、什么是面向对象 3、类 4、什么是对象的属性 5、什么是对象的方法 6、类与对象的关系/区别 对象的概念 万物皆对象，客观存在的事物皆为对象。 什么是面向对象 人 -> 关注 -> 事物信息 类 类是模子，确定对象将会拥有的特征（属性）和行为（方法）。 类的特点：类是对象的类型，具有相同属性和方法的一组对象的集合。 什么是对象的属性 属性：对象具有的各种特征，每个对象的每个属性都拥有特定值。 什么是对象的方法 方法：对象执行的操作。 类与对象的关系/区别 类是抽象的概念，仅仅是模板，比如说\"手机\"； 对象是一个你能够看得到，摸得着的具体实体。 \"手机\"类 对象 特征（属性）屏幕/CPU/内存 华为, 小米... 行为（方法）打电话/发短信 华为, 小米... 类的定义 类的重要性：所有Java程序都以 类class 为组织单元。 类的组成：属性和方法。 定义一个类的步骤： 定义类名，编写类的属性，编写类的方法 语法 public class 类名 { // 定义属性部分（成员变量） 类型 属性1; 类型 属性2; ... 类型 属性n; // 定义方法部分 方法1; 方法2; ... 方法n; } 例子 // Telphone.java package com.phone; // 1. 定义一个类Telphone public class Telphone { // 2. 属性（成员变量） float screenSize; float cpu; float memory; // 3. 方法 干什么 vodi call() { System.out.println(\"Telphone有打电话的功能\"); } vodi sendMessage() { System.out.println(\"Telphone有发短信的功能\"); } } 使用对象 使用对象的步骤： 1、创建对象 类名 对象名 = new 类名(); Telphone phone = new Telphone(); 2、使用对象 引用对象的属性：对象名.属性 // 给screenSize属性赋值5 phone.screenSize = 5; 引用对象的方法：对象名.方法名() // 调用sendMessage()方法 phone.sendMessage(); 完整例子： com.test/Telphone.java package com.test; public class Telphone { float screenSize; float cpu; float memory; void call() { System.out.println(\"call\"); } void sendMessage() { System.out.println(\"screenSize: \" + screenSize + \", cup: \" + cpu + \", memory: \" + memory); } } com.test/useTelphone.java package com.test; public class useTelphone { public static void main(String[] args) { // TODO Auto-generated method stub Telphone phone = new Telphone(); phone.sendMessage(); // 赋值 phone.screenSize = 5.4f; phone.cpu = 1.4f; phone.memory = 4.0f; phone.sendMessage(); } } 成员变量和局部变量 1、成员变量：在 类 中定义，用了描述对象将要有什么。 2、局部变量：在类的 方法 中定义，在方法中临时保存数据。 区别 成员变量 局部变量 作用域 在整个类内部都是可见的 仅限于定义它的方法中 初始值 Java会给成员变量一个初始值，调用时可以不赋值 不会赋初始值，调用前必须赋值 同一个方法中，不允许有同名局部变量。 两类变量同名时，局部变量具有更高的优先级（就近原则）。 构造方法 1、使用new 构造方法 创建一个新的对象。 2、构造方法是定义在Java类中的一个用来初始化对象的方法，构造方法与类同名且没有返回值。 3、无参构造方法的使用 main(): Telphone phone = new Telphone(); class Telphone: public Telphone() { System.out.println(\"Telphone Constractor\"); } 4、带参构造方法的使用 main(): Telphone phone2 = new Telphone(5.0f); class Telphone: public Telphone(float newScreen) { screen = newScreen; } 5、当没有指定构造方法时，系统会自动添加无参的构造方法。 6、当有指定构造方法，无论是有参、无参的构造方法，系统都不会自动添加无参的构造方法。 7、构造方法的重载：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择相应的方法。 8、构造方法不但可以给对象的属性赋值，还可以保证给对象的属性赋一个合理的值 // Tp.java package com.test pubilc class Tp { private float screen; public Tp() { System.out.println(\"com.test Tp无参构造方法执行了\"); } public Tp(float newScreen) { if (newScreen Java 中的 static 使用之静态变量 Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。当然，鉴于他作用的特殊性更推荐用类名访问~~ 使用 static 可以修饰变量、方法和代码块。 [!WARNING|style:flat|label:注意] 静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收！ Java 中的 static 使用之静态方法 与静态变量一样，使用 static 修饰的方法，称为静态方法或类方法。比如之前使用的 main 方法就是静态方法。静态方法的使用如： 1、静态方法中可以直接调用同类中的 静态成员，但不能直接调用 非静态成员。 如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量 2、在普通成员方法中，则可以直接访问 同类 的非静态变量和静态变量 3、静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法 Java 中的 static 使用之静态初始化块 Java 中可以通过初始化块进行数据赋值 public class Hello { String name; // 定义一个成员变量 // 通过初始化块，为成员变量赋值 { name = \"hello\"; } } 在类的声明中，可以包含多个初始化块，当创建类的实例时，就会依次执行这些代码块。如果使用 static 修饰初始化块，就称为静态初始化块。 [!WARNING|label:注意|style:flat] 静态初始化块只在 类加载时执行，且 只会执行一次，同时静态初始化块 只能给静态变量赋值，不能初始化普通的成员变量。 结果： 通过输出结果，我们可以看到，程序运行时静态初始化块最先被执行，然后执行普通初始化块，最后才执行构造方法。由于静态初始化块只在类加载时执行一次，所以当再次创建对象 hello2 时并未执行静态初始化块。 代码 package com.test2; public class HelloWorld { int num1; int num2; static int num3; public HelloWorld () { num1 = 91; System.out.println(\"通过构造方法为变量num1赋值\"); } { num2 = 74; System.out.println(\"通过初始化块为变量num2赋值\"); } static { num3 = 3; System.out.println(\"通过静态初始化块为静态变量num3赋值\"); } public static void main (String[] args) { HelloWorld h = new HelloWorld(); System.out.println(\"num1: \" + h.num1); System.out.println(\"num2: \" + h.num2); System.out.println(\"num3: \" + HelloWorld.num3); HelloWorld h2 = new HelloWorld(); } } 结果 通过静态初始化块为静态变量num3赋值 通过初始化块为变量num2赋值 通过构造方法为变量num1赋值 num1: 91 num2: 74 num3: 3 通过初始化块为变量num2赋值 通过构造方法为变量num1赋值 原教程出处 https://www.imooc.com/learn/124 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 23:49:28 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/second-season/encapsulation.html":{"url":"pages/second-season/encapsulation.html","title":"面向对象特性：封装","keywords":"","body":"封装 面向对象特性三大特性：封装、继承、多态 概念 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和方法。 好处 只能通过规定的方法访问数据 隐藏类的实例细节，方便修改和实现 封装的实现步骤 例子 public class Hello { provite float screen; // getter public float getScreen() { return screen; } // setter public void setScreen(float newScreen) { screen = newScreen; } } java中的包 1、作用 管理Java文件 解决同名文件冲突 2、包的定义：package 包名 [!WARNING|style:flat|label:注意] 必须放在Java源程序的第一行，包名间可以使用 . 号隔开，eg: com.test.HelloWorld // 例子：音乐类-MyClassMusic // music com.test.music.MyClassMusic; // movie com.test.movie.MyClassMusic; 3、系统中的包 java.(功能).(类) 包名 说明 java.lang.(类) 包含java语言基础的类 java.util.(类) 包含java语言中各种工具类 java.io.(类) 包含输入、输出相关功能的类 4、包的使用 可以通过import关键字，在某个文件使用其它文件中的类。 import com.test.music.MyClass; [!WARNING|style:flat|label:注意] Java中，包的命名规范是全小写字母拼写 使用的时候不但可以加载某个包下面的所有文件 com.test.*; 也可以加载某个具体包下的所有文件 com.test.music.*; Java中的访问修饰符 class Telphone { private float screen = 5.0f; public float getScreen() { return screen; } publick void setScreen(float newScreen) { screen = newScreen; } // ... } 访问修饰符，可以修饰 属性 和 方法 的访问范围。 访问修饰符 本类 同包 子类 其他 private o - - - 默认 o o - - protected o o o - public o o o o Java中的this关键字 1、this关键字代表当前对象 this.属性 操作当前对象的属性 this.方法 调用当前对象的方法 2、封装对象的属性的时候，经常会使用this关键字 # Eclipse编辑器自动生成getter/setter 菜单栏 -> source -> Generate Getters and Setters ... # 指定需要生成getter或setter方法的属性 class Telphone { private float screen = 5.0f; public float getScreen() { return screen; } publick void setScreen(float screen) { this.screen = screen; } // ... } Java中的内部类 内部类（Inner Class）就是定义在另外一个类里的类。与之对应，包含内部类的类被称为外部类。 内部类的主要作用如下： 1、内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类 2、内部类的方法可以直接访问外部类的所有数据，包括私有的数据 3、内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便 内部类可分为以下几种： 成员内部类 静态内部类 方法内部类 匿名内部类 成员内部类 public class Outer { int outerNumber = 10; // 成员内部类 public class Inner { int innerNumber = 20; public void print () { System.out.println(\"Inner class's print method, and outerNumber=\" + outerNumber); } } public static void main (String[] args) { // 创建外部类对象 Outer ou = new Outer(); // 创建内部类对象 Inner in = ou.new Inner(); // 调用内部类对象方法 in.print(); } } 成员内部类的使用方法： 1、Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如 public 、 protected 、 private 等 2、Inner 类中定义的 print() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性a 3、定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即： 内部类 对象名 = 外部类对象.new 内部类( ); 4、编译上面的程序后，会发现产生了两个 .class 文件 其中，第二个是外部类的 .class 文件，第一个是内部类的 .class 文件，即成员内部类的 .class 文件总是这样： 外部类名$内部类名.class [!WARNING|style:flat|label:注意] 1、外部类不能直接使用内部类的成员和方法 可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。 [!WARNING|style:flat|label:注意] 2、如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this关键字。如： 运行结果： 访问外部类中的b：1 访问内部类中的b：2 静态内部类 静态内部类是 static 修饰的内部类，这种内部类的特点是： 1、静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问 2、如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员 3、创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类(); 结果： 访问外部类中的b:1 访问内部类中的b:2 方法内部类 方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。 [!WARNING|style:flat|label:注意] 由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 22:18:58 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/second-season/inheritance.html":{"url":"pages/second-season/inheritance.html","title":"面向对象特性：继承","keywords":"","body":"继承 继承是类与类的一种关系，是一种is a的关系。 [!TIP|style:flat] Java中的继承是单继承。 优点： 1、子类拥有父类的所有属性和方法。private修饰符的属性和方法除外。 2、复用父类的代码（代码复用）。 语法： class 子类 extends 父类 例子 // Animal.java class Animal { // 相当于JavaScript的constructor public Animal() { // ... } public name; public age; public void eat() { System.out.println(\"调用了Animal的eat方法\"); } } // Dog.java class Dog extends Animal { } // Initial.java class Initial { public static void main() { Dog dog = new Dog(); dog.name = \"DD\"; dog.age = 2; dog.eat(); } } 方法的重写 如果子类对继承父类的方法不满意，可以重写父类继承的方法，当调用方法时会优先调用子类的方法。 语法规则： 返回值类型，方法名，参数类型及个数都要与父类继承的方法相同，才叫方法的重写 继承的初始化顺序 初始化父类再初始化子类 先执行初始化对象中属性，再执行构造方法中的初始化 final 关键字 使用final关键字做标识有最终的含义 1、final可以修饰类、方法、属性和变量 2、final修饰类，则该类不允许被继承 3、final修饰方法，则该方法不允许被覆盖（重写） 4、final修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值），或在构造方法中赋值（但只能选其一）。 5、final修饰变量，则该变量的值只能赋一次值，即变为常量。 final public class Animal { // ... } super 关键字 在对象的内部使用，可以代表父类对象。 访问父类的属性 super.age 访问父类的方法 super.eat() 例子 // Dog.java public void method() { System.out.println(super.age); } super的应用 1、子类的构造的过程当中必须调用其父类的构造方法。 2、如果子类的构造方法中没有显式调用父类的构造方法，则系统默认调用父类无参的构造方法。 3、如果显式的调用构造方法，必须在子类的构造方法的第一行。 // Dog.java public class Animal { // constructor public Animal() { super(); // 必须放在第一行 // ... } } 4、如果子类构造方法中既没有显式调用父类的构造方法，而父类又没有无参的构造方法，则编译就会出错。 Object类 Object类是所有类的父类，如果一个类没有使用extends关键字明确标识继承另外一个类，那么这个类默认继承Object类。 Object类中的方法，适合所有子类。 1、toString()方法 在Object类里面定义toString()方法的时候，返回的对象的哈希code码（对象地址字符串） 可以通过重写toString()方法表示出对象的属性 # Eclipse快速重写toString 菜单栏 -> source -> Generate toString 2、equals()方法 比较的是对象的引用是否指向同一块内存地址。 一般情况下比较两个对象时，比较他的值是否一致，所以要进行重写。 # Eclipse快速生成 source -> Generate hasCode() and equals()... © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 22:23:59 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/second-season/polymorphic.html":{"url":"pages/second-season/polymorphic.html","title":"面向对象特性：多态","keywords":"","body":"多态 对象的多种形态。引用多态、方法多态。 [!TIP|style:flat] 继承是多态实现的基础 引用多态 父类的引用可以指向本类的对象。 父类的引用可以指向子类的对象。 方法多态 创建本类对象时，调用的方法为本类方法。 创建子类对象时，调用的方法为子类重写的方法或者继承的方法。 // Animal.java package com.polymorphic; public class Animal { public void eat () { System.out.println(\"Animal has eat method.\"); } } // Dog.java package com.polymorphic; public class Dog extends Animal { // overwrite public void eat () { System.out.println(\"Dogs eat meat.\"); } } // Cat.java package com.polymorphic; public class Cat extends Animal { } // Initial.java package com.polymorphic; public class Initial { public static void main(String[] args) { /* * 引用多态/方法多态 */ // 父类的引用可以指向本类的对象 Animal obj1 = new Animal(); // 父类的引用可以指向子类的对象 Animal obj2 = new Dog(); Animal obj3 = new Cat(); // methods polymorphic obj1.eat(); obj2.eat(); obj3.eat(); /* * 引用类型转换 */ Dog dog = new Dog(); Animal animal = dog; // 自动类型提升，向上类型转换 // Warning // Dog dog2 = animal; // Type mismatch: cannot convert from Animal to Dog Dog dog2 = (Dog)animal; // 向下类型转换 强制类型转换 // error // Cat cat = (Cat)animal; // 编译时Cat类型(不会报错)，运行时Dog类型(抛出异常) // instanceof if (animal instanceof Cat) { Cat cat = (Cat)animal; } else { System.out.println(\"无法进行Cat类型转换\"); } } } 多态中的引用类型转换 向上类型转换（隐式/自动类型转换），是小类型到大类型的转换。 向下类型转换（强制类型转换），是大类型到小类型。容易发送数据溢出。 instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题。 package com.polymorphic; public class Initial { public static void main(String[] args) { /* * 引用多态/方法多态 */ // 父类的引用可以指向本类的对象 Animal obj1 = new Animal(); // 父类的引用可以指向子类的对象 Animal obj2 = new Dog(); Animal obj3 = new Cat(); // methods polymorphic obj1.eat(); obj2.eat(); obj3.eat(); /* * 引用类型转换 */ Dog dog = new Dog(); Animal animal = dog; // 自动类型提升，向上类型转换 // Warning // Dog dog2 = animal; // Type mismatch: cannot convert from Animal to Dog Dog dog2 = (Dog)animal; // 向下类型转换 强制类型转换 // error // Cat cat = (Cat)animal; // 编译时Cat类型(不会报错)，运行时Dog类型(抛出异常) // instanceof if (animal instanceof Cat) { Cat cat = (Cat)animal; } else { System.out.println(\"无法进行Cat类型转换\"); } } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 22:25:12 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/second-season/abstract.html":{"url":"pages/second-season/abstract.html","title":"Java中的抽象类","keywords":"","body":"Java中的抽象类 语法：使用abstract关键字修饰，则该类为抽象类。 [!TIP|style:flat|label:应用场景] 1、在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。（父类规定子类必须包含哪些方法，但不关心子类如何实现） 2、从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。 作用： 限制规定子类必须实现某些方法，但不关心实现细节。 使用规则： 1、abstract 定义抽象类 2、abstract 定义抽象方法，只有声明，不需要实现 3、包含抽象方法的类是抽象类 4、抽象类中可以包含普通的方法，也可以没有抽象方法 5、抽象类不能直接创建，可以定义引用变量 [!WARNING|style:flat|label:注意] 抽象方法没有方法体，以分号直接结束。 public abstract void call(); public abstract void message(); 例子 // Phone.java package com.phone; public abstract class Phone { public abstract void call(); public abstract void message(); } // CellPhone.java package com.phone; public class CellPhone extends Phone { @Override public void call() { // TODO Auto-generated method stub System.out.println(\"以前的手机，是通过键盘来打电话\"); } @Override public void message() { // TODO Auto-generated method stub System.out.println(\"以前的手机，是通过键盘来发短信\"); } } // SmartPhone.java package com.phone; public class SmartPhone extends Phone { @Override public void call() { // TODO Auto-generated method stub System.out.println(\"智能手机，是通过语音来打电话\"); } @Override public void message() { // TODO Auto-generated method stub System.out.println(\"智能手机，是通过语音来发短信\"); } } // Initial.java package com.phone; public class Initial { public static void main(String[] args) { // TODO Auto-generated method stub Phone tel1 = new CellPhone(); tel1.call(); tel1.message(); Phone tel2 = new SmartPhone(); tel2.call(); tel2.message(); } } 思考题： 现有Shape图形类，用Rectangle矩形和Circle圆形子类，求图形的周长和面积 // Shape.java package com.shape; public abstract class Shape { public abstract float getPerimeter(); public abstract float getArea(); } // Circle.java package com.shape; public class Circle extends Shape { final float PI = 3.1415926f; float radius; @Override public float getPerimeter() { // TODO Auto-generated method stub return this.checkRadius() ? 2 * PI * this.radius : 0; } @Override public float getArea() { // TODO Auto-generated method stub return this.checkRadius() ? PI * this.radius * this.radius : 0; } private boolean checkRadius() { if (this.radius == 0) { System.out.println(\"未设置圆半径\"); return false; } return true; } } // Rectangle.java package com.shape; public class Rectangle extends Shape { public float width; public float height; @Override public float getPerimeter() { if (this.width == 0 || this.height == 0) { System.out.println(\"未设置矩形的长或宽\"); return 0; } // TODO Auto-generated method stub return (this.width + this.height) * 2; } @Override public float getArea() { // TODO Auto-generated method stub return this.width * this.height; } } // Initial.java package com.shape; public class Initial { public static void main(String[] args) { // TODO Auto-generated method stub Rectangle rect = new Rectangle(); rect.width = 20.0f; rect.height = 10.0f; System.out.println(\"长方形边长为：\" + rect.getPerimeter() + \"厘米\"); System.out.println(\"长方形面积为：\" + rect.getArea() + \"平方厘米\"); // circle Circle circle = new Circle(); circle.radius = 20.0f; System.out.println(\"圆周为：\" + circle.getPerimeter() + \"厘米\"); System.out.println(\"圆面积为：\" + circle.getArea() + \"平方厘米\"); } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 22:26:18 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/second-season/interface.html":{"url":"pages/second-season/interface.html","title":"接口","keywords":"","body":"接口 接口可以理解为一种特殊的类，由全局常量和公共的抽象方法所组成。 [!TIP|style:flat|label:概念] 类是一种具体实现，而接口定义了某一批类所需要遵守的 规范，接口不关心这些类的内部数据，及类里方法的实现细节，它只规定这些类必须提供某些方法。 语法： [修饰符] abstract interface 接口名称 [extends 父接口1, 父接口2...] { 零到多个常量定义... 零到多个抽象方法的定义... } 关键字abstract可以省略，系统自动默认会添加abstract关键字。 接口就是用来被继承、被实现的，修饰符一般建议用public [!WARNING|style:flat|label:注意] 不能使用private和protected修饰接口 接口定义 1、常量： 接口中的属性是常量，即使定义时不添加 public static final 修饰符，系统也会自动加上。 2、方法： 接口中的方法只能是抽象方法，即使定义时不添加 public abstract 修饰符，系统也会自动加上。 使用接口 一个类可以实现一个或多个接口，实现接口使用implements关键字。Java中一个类只能继承一个父类，是不够灵活的，通过实现多个接口来做补充（弥补）。 继承父类实现的接口语法： [修饰符] class 类名 extends 父类 implements 接口1, 接口2... { // 类体部分 // 如果继承了抽象类，则必须实现继承的抽象方法 // 如果遵守了某个接口，则必须实现接口中的抽象方法 } [!WARNING|style:flat|label:注意] 如果 继承了 抽象类，则必须实现继承的类规定的抽象方法 如果 遵守了某个接口，则必须实现接口中的抽象方法 如果要继承父类，则继承父类必须在实现接口以前，即extends与 implements不能交换位置。 // new -> interface // IPlayGame.java package com.phone; public interface IPlayGame { public void playGame(); } // 系统会默认添加abstract关键字 //public abstract interface IPlayGame { // public abstract void playGame(); //} // SmartPhone.java package com.phone; public class SmartPhone extends Phone implements IPlayGame { @Override public void call() { // TODO Auto-generated method stub System.out.println(\"智能手机，是通过语音来打电话\"); } @Override public void message() { // TODO Auto-generated method stub System.out.println(\"智能手机，是通过语音来发短信\"); } @Override public void playGame() { // TODO Auto-generated method stub System.out.println(\"智能手机具有了玩游戏的功能\"); } } // Psp.java package com.phone; public class Psp implements IPlayGame { @Override public void playGame() { // TODO Auto-generated method stub System.out.println(\"PSP具有了玩游戏的功能\"); } } // Initial.java package com.phone; public class Initial { public static void main(String[] args) { // TODO Auto-generated method stub Phone tel1 = new CellPhone(); tel1.call(); tel1.message(); Phone tel2 = new SmartPhone(); tel2.call(); tel2.message(); // Interface IPlayGame ip1 = new SmartPhone(); ip1.playGame(); IPlayGame ip2 = new Psp(); ip2.playGame(); } } 匿名内部类 匿名内部类：就是没有名称的内部类。 接口在使用过程当中，还经常与匿名内部类配合使用。 多用于关注实现，而不关注实现类的名称。 语法： Interface i = new Interface() { public void method() { System.out.println(\"匿名内部类实现接口的方式\"); } } package com.phone; public class Initial { public static void main(String[] args) { // TODO Auto-generated method stub Phone tel1 = new CellPhone(); tel1.call(); tel1.message(); Phone tel2 = new SmartPhone(); tel2.call(); tel2.message(); // Interface IPlayGame ip1 = new SmartPhone(); ip1.playGame(); IPlayGame ip2 = new Psp(); ip2.playGame(); // 匿名内部类实现接口 IPlayGame ip3 = new IPlayGame() { @Override public void playGame() { // TODO Auto-generated method stub System.out.println(\"匿名内部类实现接口的方式\"); } }; ip3.playGame(); // 直接new // Android中使用较为频繁 new IPlayGame() { @Override public void playGame() { // TODO Auto-generated method stub System.out.println(\"直接使用new，实现匿名内部类接口\"); } }.playGame(); } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 22:32:26 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/second-season/UML.html":{"url":"pages/second-season/UML.html","title":"UML(Unified Modeling Language)","keywords":"","body":"UML Unified Modeling Language（UML），统一建模语言或标准建模语言。 是一个支持模型化和软件系统开发的图形化语言。 为软件开发的所以阶段提供模型化和可视化支持。 UML图示 UML 2.2一共定义了14中图示（diagrams）。 常用UML图 用例图（The Use Case Diagram） [!TIP|style:flat|label:The Use Case Diagram] 用例图能够以可视化的方式，表达系统如何满足所收集的业务规则，以及特定的用户需求等信息。 序列图（The Sequence Diagram） [!TIP|style:flat|label:The Sequence Diagram] 序列图用于安装交互发生的一系列顺序，显示对象之间的这些交互。 类图（The Class Diagram） [!TIP|style:flat|label:The Class Diagram] UML类图、业务逻辑和所有支持结构一同被用于定义全部的代码结构。 UML建模工具 Microsoft Office Visio、Rational Rose、PowerDesign三种建模工具应用最广。 参考资料： https://www.cnblogs.com/Ph-one/p/7650624.html https://www.eclipse.org/modeling/mdt/downloads/?project=uml2 https://www.cnblogs.com/silent2012/archive/2011/09/07/2169946.html UML学习入门就这一篇文章 转自：http://www.uml.org.cn/oobject/201309023.asp 1.1 UML基础知识扫盲 UML这三个字母的全称是Unified Modeling Language，直接翻译就是统一建模语言，简单地说就是一种有特殊用途的语言。 你可能会问：这明明是一种图形，为什么说是语言呢?伟大的汉字还不是从图形(象形文字)开始的吗?语言是包括文字和图形的!其实有很多内容文字是无法表达的，你见过建筑设计图纸吗?里面还不是很多图形，光用文字能表达清楚建筑设计吗?在建筑界，有一套标准来描述设计，同样道理，在软件开发界，我们也需要一套标准来帮助我们做好软件开发的工作。UML就是其中的一种标准，注意这可不是唯一标准，只是UML是大家比较推崇的一种标准而已，说不定以后有一个更好的标准可能会取代她呢!UML并不是强制性标准，没有法律规定你在软件开发中一定要用UML，不能用其它的，我们的目标是善用包括UML在内的各种标准，来提高我们软件开发的水平。 UML由1.0版发展到1.1、1.2、...，到现在的2.0、2.x，本书将会以2.x版本为基础开展讨论。网络上、书籍、还有各种UML工具软件，各自基于的UML版本可能会不一样，大家在学习过程中可能会有一些困惑，不过没关系，本课程在某些关键地方会描述1.x与2.x的差异。 UML有什么用? 有很多人认为，UML的主要用途就是软件设计!也有人认为，如果你不是开发人员，是难以理解UML的。 然而我第一次在实际工作中应用UML的却不是软件设计，而是软件需求分析!当时我们和客户面对面沟通调研需求的时候，直接用类图、顺序图、活动图、用例图等UML。我们并没有因此和客户无法沟通，反而是沟通得更加顺畅。客户在我们的引导下，很快就会读懂这些UML图，因为UML图，让我们和客户的沟通效率和效果更好!你可能觉得很神奇，在后续章节中，我将会为你逐一揭开神奇背后的“秘密”。 UML可帮助我们做软件需求分析和软件设计的工作，在我工作中大概各占了50%的比例，当然在你的实际工作中不一定是这样的比例。UML会让你的需求分析或者软件设计工作更上一层楼，本书将会介绍UML在需求分析方面的最佳实践。 告诉你一个秘密，UML应用于软件需求分析时，其学习门槛将会大大降低!语法复杂度会降低，而且你基本不需要掌握软件开发的知识。只要你对软件需求分析感兴趣，认真学习和应用UML，就很有机会成为软件需求分析高手。 UML的分类 结构型的图(Structure Diagram) 类图(Class Diagram) 对象图(Object Diagram) 构件图(Component Diagram) 部署图(Deployment Diagram) 包图(Package Diagram) 行为型的图(Behavior Diagram) 活动图(Activity Diagram) 状态机图(State Machine Diagram) 顺序图(Sequence Diagram) 通信图(Communication Diagram) 用例图(Use Case Diagram) 时序图(Timing Diagram) 本书所描述的UML的各种图的名字，以上述的为准。 UML各种图的中文译名，因为翻译的原因可能会有所不一样，如：Sequence Diagram和Timing Diagram有时候都会被译成“时序图”，这是最让人困扰的地方!Sequence Diagram 除了被译为顺序图，还有序列图的译法。 中国软件行业协会(CSIA)与日本UML建模推进协会(UMTP)共同在中国推动的UML专家认证，两个协会共同颁发认证证书、两国互认，CSIA与UMTP共同推出了UML中文术语标准，该标准全称为：CSIA-UMTP UML中文术语标准v1.0(本书后文将会简称为UML中文术语标准)。本书将会遵循UML中文术语标准，并且我们会同时给出中文译名和英文原名，大家要留意看英文名字噢，这样能帮助你不会被众多的中文译名混淆。 UML图为什么会分为结构型和行为型两种呢? 顾名思义，结构型的图描述的是某种结构，这种结构在某段时间内应该是稳定的，“静态”的;而结构型的图描述的是某种行为，是“动态”的。 分析系统需求时，我们会面对很多业务概念，它们之间会有某些关系，这些内容可以看成是“静态”的，我们可以利用UML的结构性的图来分析。同时，业务会涉及大量的流程、过程等，这些内容是“动态”的，我们可以用行为型的UML图来分析。 在我们软件设计时，我们需要考虑需要那些类、哪些构件、系统最后怎样部署等，这些内容可以看成是“静态”的，我们可以利用UML的结构型的图来设计。同时，我们也需要考虑软件如何和用户交互，类、构件、模块之间如何联系等“动态”内容，我们可以利用行为型的图来设计。 所谓“静态”和“动态”不是绝对的，下文我们将会进一步介绍结构型的UML和行为型的UML。通过下面的学习，你将会初步认识UML的各种图，你可能还会有很多问题，本章的主要目的是让你对UML有一个宏观的认识，带着你的问题继续阅读后面的章节吧! 1.2 结构型的UML(Structure Diagram) 类图(Class Diagram) 某模具系统类图 此图截取自某模具管理系统的业务概念分析图，图中一个一个的矩形就是类，这些类之间有各种线条连接，这些线条表示类之间的关系。类图是分析业务概念的首选，类图可能是使用率最高的UML图。 再看下面这个Person类图，这时软件设计时用到的一个图： Person类图 该Person类有以下属性(Attribute)：Name(姓名),Sex(性别),Department(部门)等，有以下操作(Operation)：Work(工作)等。类有属性和操作，但用类图分析业务模型时，往往不需要使用操作，如图1.1中的类就只有属性。 Attribute有特性、特征等译法，Operation也称作方法，但本书遵循UML中文术语标准，即Attribute为属性，Operation为操作。 对象图(Object Diagram) 一般情况下只有在软件开发中才会使用到对象图，下面的内容以开发的角度来说明对象图，如果你没有开发经验，阅读起来可能有一点难度。 图1.2中的Person类，用代码实例化如下： Person person = new Person(); …… 类(Class)实例化后就是对象(Object)，对象person是类Person的实例，上述代码可以用对象图表示如下： Person类的对象图 对象图和类图的样子很相似，对象是类的实例化，“person : Person”表示对象person是类Person的实例。对象图往往只在需要描述复杂算法时才会使用，画出来的对象图往往不会只有一个对象，该图只画了一个对象，其目的是尽量简化以便读者的理解什么是对象图。 在需求分析工作中基本上不需要使用对象图，从严谨的角度来看某些情况下应该使用对象图，但我往往还是会用类图来处理，这样更加简便而且容易理解。我们将在类图一章再次讲解对象图。 构件图(Component Diagram) 构件图也叫组件图，两个名字均符合UML中文术语标准。 一辆汽车由轮子、发动机等物理部件组成，一个软件往往也是由很多“物理部件”(如：控件、重用构件等)组成的，构件图就是用来描述软件内部物理组成的一种图。下图是某权限构件设计图： 图1.4某权限构件设计图 图1.4右上方有这样标志 的矩形表示一个构件，构件可以再包含构件。 软件需求分析工作中，需要用到构件图的情况不是很多，以下情况除外： 1、待开发的系统需要与第三方的系统、原有系统、某些老系统等交互，这时可用构件图描述交互要求。 2、客户对软件设计有某些特殊要求，这时可用构件图来描述要求。 构件图有时不会单独使用，还会和部署图一起结合使用。 部署图(Deployment Diagram) 部署图是用来描述系统如何部署、本系统与其他系统是怎样的关系的一种图，如下图： 图 1.5 某24小时便利店的管理系统部署图 图中一个个立体的矩形是部署图的“节点”，一个节点表示一个物理的设备，节点之间的线条表示节点间的物理连接关系。 大部分客户都会具备一定的IT基础环境(如具备局域网、一些服务器、某些软件平台等)，软件系统需要基于当前的IT基础环境来规划，这时我们可以使用部署图来做这个规划。 分析系统的需求，不能忽略系统架构、部署、IT架构等方面的要求，我们要基于客户当前的IT基础环境，做一个最符合客户利益的规划。 要活用构件图、部署图来分析需求，需要具备一定的IT基础架构知识和软件设计知识，如果你还不具备相关知识，那么可以考虑抓紧补充相关知识。不过需求分析工作更多的还是分析业务，提炼功能性需求，这部分工作能做好是相当不容易的事情。对于技术方面的非功能性需求分析，可交由有技术背景的专业人士负责。 包图(Package Diagram) Package有“打包”的意思，包图的主要用途是“打包”类图。用类图描述业务概念时，很多时候会因为业务类太多，而导致类图非常庞大，不利于阅读，这时可以将某些类放入“包”中，通过包图来组织业务概念图。 下图是包图的一个示例： 包图 图中好像文件夹样子的就是一个“包”，包之间的线条表示包之间的关系。 1.3 行为型的UML(Behavior Diagram) 活动图、状态机图、顺序图处于三种不同的角度来描述流程，是分析业务流程的三种不同利器，下面将会逐一说明。 活动图(Activity Diagram) 我们将起床到出门上班这个过程画成活动图，可能是这样的： 图 1.7 起床到出门上班的活动图 活动图中的一个圆边框框表示一个“活动”，多个活动之间的带箭头线条表示活动的先后顺序，该图只是表达了一个顺序流程，活动图还可以表达分支结构。如果你以前曾学过流程图的话，你会发现活动图和流程图很相似。活动图可能是三种能表示流程的UML图中最接近我们思维习惯的一种，下面来学习另外两种能表达流程的图。 状态机图(State Machine Diagram) 状态机图又叫状态图，但状态图这个译名并没有译出Machine的意思。 状态机图从某个物品的状态是如何变化的角度来展示流程，下图某请假条审批流程： 图 1.8 请假处理流程 整个请假审批流程是围绕“请假条”这个物体进行的，随着不同的审批阶段，请假条具备不同的状态。我们分析业务流程时会发现很多流程其实是围绕某个物品进行的，这时可考虑使用状态机图。 顺序图(Sequence Diagram) 你去餐厅吃饭，向服务员点餐到服务员送菜上来，这个过程用顺序图可表示如下： 图 1.9 点菜的顺序图 该图有三个“小人”，每个“小人”下面的文字说明(如：顾客)表示其代表的角色。角色与角色之间有一些线条链接，表示角色之间是如何交互的。该图表示的意思是：顾客向服务员点菜后，服务员将点菜信息传递给厨师，然后厨师做菜，最后再由服务员送菜给你。 点菜过程涉及几个环节，每个环节均由不同的角色来负责，如果遇到类似的情况，你可以考虑使用顺序图来分析。用顺序图来分析的好处是能清晰表达整个过程所参与的角色，角色与角色之间的关系，各角色是如何被卷入这个过程当中的。 通信图(Communication Diagram) UML1.1时，该图英文名为Collaboration Diagram;UML2.x时，英文名为Communication Diagram。将英文名字直接翻译，原来的英文名字可译为协作图，而新的英文名字译为通信图。 通信图是顺序图的另外一种画法，点菜的顺序图，如果用通信图来画可表示如下： 图 1.10 点菜的通信图 三个“小人”分表表示三种角色：顾客、服务员、厨师;角色之间有直线联系表示他们之间有关系;带序号的文字和箭头，表示角色之间传递的信息。 顺序图更强调先后顺序，通信图更强调相互之间的关系。我觉得顺序图实用性更好一点，比通信图能表达更多的信息，更容易读懂，在需求分析工作中我基本不会使用通信图。 用例图(Use Case Diagram) 下图是用例图的示意图： 图 1.11 用例图 用例图表达的是什么角色通过软件系统能做什么事情，我们可以使用用例图系统地表达软件系统的绝大部分需求。 时序图(Timing Diagram) 时序图也叫时间图，时序图是UML中文术语标准的说法，而时间图不是标准的说法。 时序图是表示某东西的状态随时间变化而变化的一种图，参见下图： 图 1.12 灯的开关状态随时间变化图 此图表示在0秒到30秒，灯的状态是关的，30-60秒灯的状态为开，60秒后状态为关。 在实际工作中我基本上没有试用过时间图。 下面通过这个表格来总结一下我在需求分析工作中应用各种UML图的情况： 表 1.1 各种UML图实际应用情况 上表是根据我的工作经验总结的，相信会适用于很多情况。但每个人的工作经历、情况、环境等不太一样，上表仅作参考。 1.4 如何学好UML? UML的认识误区 误区一：认为UML主要用于软件设计。 前面的文章你可以看到，UML除了用于软件设计，还能用于需求分析，而本书就是专门来说明如何在需求分析工作中活用UML的。 误区二：客户无法理解UML，在需求分析中应用UML实际意义不大。 我还不熟悉UML时，确实也有这样的怀疑，而实际工作中发现UML恰恰成为与客户沟通的良好桥梁!UML其实不难读懂，只要稍加解释客户马上就能读懂。我在所有的项目需求分析工作中，都直接使用UML图与客户沟通，并且给客户签署的需求规格说明书中含有大量的UML图。 UML能直观、形象、严谨地描述出业务概念、业务流程、客户的期望和需求，只要稍加引导客户，客户将会很容易读懂UML，甚至会主动使用UML与项目组交流。我曾经遇到过客户向我们索要画UML图的工具，客户见识过UML的威力后，也想在自己实际工作中使用。 误区三：认为UML语法繁杂，难以学习和应用。 某些UML资料和书籍可能将UML说得过于复杂了，官方的UML标准资料也确实是枯燥难懂、人见人晕。我刚开始学习UML时，也看过一些UML书籍，觉得UML的语法太多、太复杂、太容易混淆了! 在实际工作中，其实经常需要用到的UML语法并不多，而且很容易掌握。当我们在需求分析方面应用UML时，需要掌握的语法更少(在软件设计方面应用UML时需要掌握稍多一点的语法)。“二八原则”在这里完全适用，我们经常用到的UML语法，其实只占全部语法的20%，而本书将会重点介绍实用性强的UML语法。 误区四：UML用途不大。 很多人推崇UML，但也有不少人士不太认可UML。不认可的原因主要是因为一些人士学习UML后，发现在实际工作中发挥的作用并不是很大，有时候不用UML效果更好。 我不敢说UML能帮助我们解决所有问题，至少从我的多年使用经验上来说，UML对于提升我的需求分析能力帮助还是很大的。有人之所以感觉UML不太好用，我觉得原因还是只掌握了UML的形而没有领会UML的神。UML的常用语法可能几天就能学会了，而要真正做到“thinking in UML”却没有这么容易，需要长期的锻炼。 我的学习经历 我读大学时没有听说过UML，出来工作两三年后才开始接触UML，当时的感觉就好像找到了新大陆，很想好好发掘一番!而我当时的运气还是相当不错的，我的上司是UML达人，他带领我参加了项目的需求分析工作。我很快就见识了UML威力，在他的言传身教之下，迅速掌握了UML。 在那个项目以后，我便独立担当了多个项目管理及需求分析工作，没有一个项目不应用UML，而且我毫不保留地传授UML知识给项目组的其他成员。多年的工作进一步磨练了自己，对UML在实际工作中的应用有了更深刻的认识，形成自己的一套方法。 我的UML知识绝大部分来自于工作实践，期间虽然也看过一些书籍，但对我的帮助很少。当然我最大的得益还是来自我的UML启蒙老师，他在实际工作中教会了我UML，帮助我踏上自我成长的道路。 我的UML学习最大体会就是：实践太重要了!如果有名师指导则会让你事半功倍!希望本书能成为你在实际工作中学习和应用UML的好帮手! UML学习难点 学UML之难，不在于学习语法，关键是要改变思维习惯。UML是一种新的工具，但同时也是代表了一种新的先进的思考方法，如果不能掌握这样的方法，只能学到了UML的形，而没有掌握其神髓。 要用好UML，你需要在平时多多培养下面的能力： 1、书面表达能力。 2、归纳总结能力。 3、“面向对象”的思维能力和抽象能力。 平时你可以利用各种机会来提升第1和第2种能力，如多写写项目文档、写写日记或博客等，多思考和总结平时自己的工作得失等。 第3种能力说起来有点虚，大家在大学中可能也学过相关知识。训练这种能力的最好方法就是多应用类图，我们将会在类图的章节再重点介绍，通过实例来体会什么才叫“面向对象”! 本书将会重点培养你的这三种能力，只要你有进步之心，多练习、多实践、多思考、多总结，一定会取得长足进步! 1.5 小结 本章的主要目标是让你不需要阅读全书的情况下，就可以了解到UML的全貌，大概知道UML各种图的用途，同时给你说明学习UML的难点，为最终活用UML做好准备。下面我们一起来复习一下本章的主要内容： UML是Unified Modeling Language的简称，是软件开发界的一套标准，UML不仅可用于软件设计，也可以用于软件需求分析。但UML并不是强制标准，我们应该善用包括UML在内的各种标准来提高我们的水平。 UML可分为两类：结构型、行为型，结构性的UML有：类图、对象图、构件图、部署图、包图，行为型的图有活动图、状态机图、顺序图、通信图、用例图、时间图。 类图是业务概念模型分析的有利武器，也是面向对象分析能力的强有力训练工具。 对象图在需求分析工作中并不常用。 构件图、部署图是分析IT基础架构、软件架构等方面需求的有利分析工具，但需要你具备IT基础架构、软件设计方面的知识和经验。 包图可用来组织类图，在需求分析工作中应用的机会不是很大。 活动图、状态机图、顺序图是分析业务流程的强力武器。活动图的表达思路与流程图很类似，很容易掌握，而且大部分情况下都可以使用活动图来分析业务流程;某流程如果是围绕某个物品进行，该物品在流程中转换多种状态，那么使用状态机图来分析是首选;用顺序图来分析的好处是能清晰表达整个过程所参与的角色，角色与角色之间的关系，各角色是如何被卷入这个过程当中的。 通信图可以看作是顺序图的另外一种表达形式，顺序图更强调先后顺序，通信图更强调相互之间的关系。而从我的工作经验看，顺序图更加实用一点。 有人会将用例图称作“公仔图”，用例图表达的是什么角色通过软件系统能做什么事情，我们可以使用用例图系统地表达软件系统的绝大部分需求。 时间图是表示某东西的状态随时间变化而变化的一种图，我在实际工作中很少有机会能用到这种图。 学UML之难，不在于学习语法，避免陷入UML的认识误区，多练习、多实践，培养良好的“think in UML”思想，锻炼面向对象分析的能力，成为活用UML的需求分析高手不远矣! © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 22:57:38 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "},"pages/third-season/exception.html":{"url":"pages/third-season/exception.html","title":"异常与异常处理","keywords":"","body":"异常与异常处理 字面意思：有异于常态，和正常情况不一样，有错误出现。 程序中：阻止当前方法或作用域正常运行的情况，称之为异常。 [!TIP|style:flat|label:Exception异常] 异常指的是在程序运行过程中发生的异常事件，通常是由外部问题（如硬件错误、输入错误）所导致的。在Java等面向对象的编程语言中异常属于对象。 导致的问题： 1、程序得不到正常的运行，不能正常退出 2、导致用户数据丢失 3、程序运行的资源得不到有效的释放 异常处理作用： 1、对异常正确的处理，能将异常提示给编程人员或者是用户 2、使已中断的程序，以适当的方式继续运行或退出，并且可以保存用户的当前操作，或数据回滚 3、最后再把占用的资源释放掉 Throwable类 主要有两个儿子Error与Exception，即Error与Exception类继承Throwable类 Error 错误 [!TIP|style:flat|label:Error] 系统错误，内存溢出 虚拟机错误 VirtualMachineError 线程死锁 ThreadDeath 它的出现，即意味着程序挂了，即程序终结者 好比工厂停水/停电/机器挂了 Exception 异常 [!TIP|style:flat|label:Exception] 编码、环境、用户操作输入出现问题 主要有 RuntimeException 称之为非检查异常 其他异常称之为：检查异常 CheckException 非检查异常 RuntimeException 引起RuntimeException的原因： 1、引用了一个空对象或方法。空指针异常 NullPointerException String str = null; System.out.println(str.length()); 2、数组访问越界。数组下标越界异常 ArrayIndexOutOfBoundsException int[] arr = { 1, 2, 3 } for (int i = 0; i 3、错误的类型转换。类型转换异常 ClassCastException class Animal {} class Dog extends Animal {} class Cat extends Animal {} public class Test { public static void main (String[] args) { Animal a1 = new Dog(); Animal a2 = new Cat(); Dog d1 = (Dog)a1; Dog d2 = (Dog)a2; } } 4、运算异常，整数去整除零。算术异常 ArithmeticException int a = 12; int b = 0; System.out.println(a / b); 5、等等... [!TIP|style:flat] 运行时异常 会由Java虚拟机自动抛出，并自动捕获。 运行时异常的出现，多数情况下说明代码本身出了问题，应该从逻辑上去改进代码。 检查异常 CheckException 比如：文件异常 IOException，SQl异常 SQLException等等很多，需要开发人员自己捕获及处理。 异常处理 try-catch, try-catch-finally 原视频教程出处 https://www.imooc.com/learn/110 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2019-04-03 23:03:22 window.klipse_settings = { selector: \".language-klipse, .lang-eval-clojure\", selector_eval_js: \".lang-eval-js\", selector_eval_python_client: \".lang-eval-python\", selector_eval_php: \".lang-eval-php\", selector_eval_scheme: \".lang-eval-scheme\", selector_eval_ruby: \".lang-eval-ruby\", selector_reagent: \".lang-reagent\", selector_google_charts: \".lang-google-chart\", selector_es2017: \".lang-eval-es2017\", selector_jsx: \".lang-eval-jsx\", selector_transpile_jsx: \".lang-transpile-jsx\", selector_render_jsx: \".lang-render-jsx\", selector_react: \".lang-react\", selector_eval_markdown: \".lang-render-markdown\", selector_eval_lambdaway: \".lang-render-lambdaway\", selector_eval_cpp: \".lang-eval-cpp\", selector_eval_html: \".lang-render-html\", selector_sql: \".lang-eval-sql\", selector_brainfuck: \"lang-eval-brainfuck\", selector_js: \".lang-transpile-cljs\" }; "}}